#!/usr/bin/env node

"use strict";
exports.id = 1324;
exports.ids = [1324];
exports.modules = {

/***/ 597275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbiFeaturesCollector = exports.collectAbiFeatures = exports.allFeatures = void 0;
const visitor_1 = __webpack_require__(980817);
exports.allFeatures = [
    "defines-receive",
    "defines-fallback",
    "needs-abiencoder-v2",
    "defines-error",
];
const collectAbiFeatures = (node) => (0, visitor_1.dispatch)({
    node,
    visitor: new AbiFeaturesCollector(),
});
exports.collectAbiFeatures = collectAbiFeatures;
class AbiFeaturesCollector {
    visitAbi({ node: nodes }) {
        return nodes
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
    }
    visitEventEntry({ node: entry }) {
        return entry.inputs
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
    }
    visitErrorEntry({ node: entry }) {
        return entry.inputs
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
    }
    visitFunctionEntry({ node: entry, }) {
        return [...entry.inputs, ...(entry.outputs || [])]
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
    }
    visitConstructorEntry({ node: entry, }) {
        return entry.inputs
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
    }
    visitFallbackEntry({ node: entry, }) {
        return { "defines-fallback": true };
    }
    visitReceiveEntry({ node: entry, }) {
        return { "defines-receive": true };
    }
    visitParameter({ node: parameter, }) {
        if (parameter.type.startsWith("tuple") || // anything with tuples
            parameter.type.includes("string[") || // arrays of strings
            parameter.type.includes("bytes[") || // arrays of bytes
            parameter.type.includes("][") // anything with nested arrays
        ) {
            return { "needs-abiencoder-v2": true };
        }
        return {};
    }
}
exports.AbiFeaturesCollector = AbiFeaturesCollector;
//# sourceMappingURL=abi-features.js.map

/***/ }),

/***/ 742598:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.collectDeclarations = exports.DeclarationsCollector = void 0;
const Codec = __importStar(__webpack_require__(20102));
const visitor_1 = __webpack_require__(980817);
class DeclarationsCollector {
    visitAbi({ node: nodes }) {
        return nodes
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce(mergeDeclarations, emptyDeclarations());
    }
    visitEventEntry({ node: entry }) {
        return entry.inputs
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce(mergeDeclarations, emptyDeclarations());
    }
    visitErrorEntry({ node: entry }) {
        return entry.inputs
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce(mergeDeclarations, emptyDeclarations());
    }
    visitFunctionEntry({ node: entry, }) {
        return [...entry.inputs, ...(entry.outputs || [])]
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce(mergeDeclarations, emptyDeclarations());
    }
    visitConstructorEntry({ node: entry, }) {
        return entry.inputs
            .map((node) => (0, visitor_1.dispatch)({ node, visitor: this }))
            .reduce(mergeDeclarations, emptyDeclarations());
    }
    visitFallbackEntry({ node: entry, }) {
        return emptyDeclarations();
    }
    visitReceiveEntry({ node: entry, }) {
        return emptyDeclarations();
    }
    visitParameter({ node: parameter }) {
        if (!parameter.type.startsWith("tuple")) {
            return emptyDeclarations();
        }
        let container = "";
        const components = parameter.components || [];
        const signature = Codec.AbiData.Utils.abiTupleSignature(components);
        const declaration = {
            components: components.map(({ name, type, components }) => !components
                ? { name, type }
                : {
                    name,
                    type,
                    signature: Codec.AbiData.Utils.abiTupleSignature(components),
                }),
        };
        if ("internalType" in parameter && parameter.internalType) {
            const match = parameter.internalType.match(/struct ([^\[]+).*/);
            if (match) {
                const possiblyQualifiedIdentifier = match[1];
                const parts = possiblyQualifiedIdentifier.split(".");
                if (parts.length === 1) {
                    declaration.identifier = parts[0];
                }
                else if (parts.length === 2) {
                    container = parts[0];
                    declaration.identifier = parts[1];
                }
            }
        }
        const declarations = {
            signatureDeclarations: {
                [signature]: declaration
            },
            containerSignatures: {
                [container]: [signature]
            }
        };
        const componentDeclarations = components
            .map((component) => this.visitParameter({ node: component }))
            .reduce(mergeDeclarations, emptyDeclarations());
        return mergeDeclarations(declarations, componentDeclarations);
    }
}
exports.DeclarationsCollector = DeclarationsCollector;
const collectDeclarations = (node) => (0, visitor_1.dispatch)({
    node,
    visitor: new DeclarationsCollector(),
});
exports.collectDeclarations = collectDeclarations;
function mergeDeclarations(a, b) {
    const declarations = {
        signatureDeclarations: Object.assign(Object.assign({}, a.signatureDeclarations), b.signatureDeclarations),
        containerSignatures: Object.assign({}, a.containerSignatures)
    };
    for (const [container, signatures] of Object.entries(b.containerSignatures)) {
        const mergedSignatures = new Set([
            ...(declarations.containerSignatures[container] || []),
            ...signatures
        ]);
        declarations.containerSignatures[container] = [...mergedSignatures];
    }
    return declarations;
}
function emptyDeclarations() {
    return {
        signatureDeclarations: {},
        containerSignatures: {}
    };
}
//# sourceMappingURL=declarations.js.map

/***/ }),

/***/ 523836:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.outputSource = exports.outputAttribution = exports.prettifyOutput = exports.solidityVersion = exports.license = exports.name = void 0;
exports.name = "MyInterface";
exports.license = "UNLICENSED";
exports.solidityVersion = ">=0.7.0 <0.9.0";
exports.prettifyOutput = true;
exports.outputAttribution = true;
exports.outputSource = true;
//# sourceMappingURL=defaults.js.map

/***/ }),

/***/ 801324:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateSolidity = exports.defaults = void 0;
__webpack_require__(20406);
exports.defaults = __importStar(__webpack_require__(523836));
var solidity_1 = __webpack_require__(198376);
Object.defineProperty(exports, "generateSolidity", ({ enumerable: true, get: function () { return solidity_1.generateSolidity; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 198376:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateSolidity = void 0;
const Codec = __importStar(__webpack_require__(20102));
const package_json_1 = __webpack_require__(997973);
const visitor_1 = __webpack_require__(980817);
const version_features_1 = __webpack_require__(91727);
const defaults = __importStar(__webpack_require__(523836));
const declarations_1 = __webpack_require__(742598);
const abi_features_1 = __webpack_require__(597275);
let prettier;
try {
    prettier = __webpack_require__(708716);
}
catch (_a) {
    // no-op
}
const generateSolidity = ({ abi, name = defaults.name, solidityVersion = defaults.solidityVersion, license = defaults.license, outputAttribution = defaults.outputAttribution, outputSource = defaults.outputSource, prettifyOutput = prettier && defaults.prettifyOutput, }) => {
    if (!prettier && prettifyOutput) {
        throw new Error("Could not require() prettier");
    }
    const versionFeatures = (0, version_features_1.forRange)(solidityVersion);
    const abiFeatures = (0, abi_features_1.collectAbiFeatures)(abi);
    const declarations = (0, declarations_1.collectDeclarations)(abi);
    const generated = (0, visitor_1.dispatch)({
        node: abi,
        visitor: new SolidityGenerator({
            name,
            solidityVersion,
            license,
            outputAttribution,
            outputSource,
            versionFeatures,
            abiFeatures,
            declarations,
        }),
    });
    if (!prettifyOutput) {
        return generated;
    }
    try {
        return prettier.format(generated, {
            plugins: ["prettier-plugin-solidity"],
            // @ts-ignore
            parser: "solidity-parse",
        });
    }
    catch (error) {
        return generated;
    }
};
exports.generateSolidity = generateSolidity;
const shimGlobalInterfaceName = "__Structs";
class SolidityGenerator {
    constructor({ name, license, outputAttribution, outputSource, solidityVersion, versionFeatures, abiFeatures, declarations, }) {
        this.name = name;
        this.license = license;
        this.solidityVersion = solidityVersion;
        this.versionFeatures = versionFeatures;
        this.abiFeatures = abiFeatures;
        this.declarations = declarations;
        this.outputAttribution = outputAttribution;
        this.outputSource = outputSource;
        this.identifiers = {};
        let index = 0;
        for (const [container, signatures] of Object.entries(declarations.containerSignatures)) {
            for (const signature of signatures) {
                const { identifier = `S_${index++}` } = declarations.signatureDeclarations[signature];
                if (container === "" && this.versionFeatures["global-structs"] !== true) {
                    this.identifiers[signature] = {
                        container: shimGlobalInterfaceName,
                        identifier
                    };
                }
                else if (container === "") {
                    this.identifiers[signature] = { identifier };
                }
                else {
                    this.identifiers[signature] = {
                        container,
                        identifier
                    };
                }
            }
        }
    }
    visitAbi({ node: abi }) {
        return [
            this.generateHeader(),
            this.generateInterface(abi),
            this.generateDeclarations(),
            this.generateAutogeneratedNotice(abi),
        ].join("\n\n");
    }
    visitFunctionEntry({ node: entry, context }) {
        const { name, inputs, stateMutability } = entry;
        return [
            `function ${name}(`,
            entry.inputs.map((node) => (0, visitor_1.dispatch)({
                node,
                visitor: this,
                context: Object.assign(Object.assign({}, context), { parameterModifiers: (parameter) => parameter.type.startsWith("tuple") ||
                        parameter.type.includes("[") ||
                        parameter.type === "bytes" ||
                        parameter.type === "string"
                        ? [this.generateArrayParameterLocation(parameter)]
                        : [] }),
            })),
            `) external`,
            this.generateStateMutability(entry),
            entry.outputs && entry.outputs.length > 0
                ? [
                    `returns (`,
                    entry.outputs
                        .map((node) => (0, visitor_1.dispatch)({
                        node,
                        visitor: this,
                        context: {
                            parameterModifiers: (parameter) => parameter.type.startsWith("tuple") ||
                                parameter.type.includes("[") ||
                                parameter.type === "bytes" ||
                                parameter.type === "string"
                                ? ["memory"]
                                : [],
                        },
                    }))
                        .join(", "),
                    `)`,
                ].join("")
                : ``,
            `;`,
        ].join(" ");
    }
    visitConstructorEntry({ node: entry }) {
        // interfaces don't have constructors
        return "";
    }
    visitFallbackEntry({ node: entry }) {
        const servesAsReceive = this.abiFeatures["defines-receive"] &&
            this.versionFeatures["receive-keyword"] !== true;
        const { stateMutability } = entry;
        return `${this.generateFallbackName()} () external ${stateMutability === "payable" || servesAsReceive ? "payable" : ""};`;
    }
    visitReceiveEntry() {
        // if version has receive, emit as normal
        if (this.versionFeatures["receive-keyword"] === true) {
            return `receive () external payable;`;
        }
        // if this ABI defines a fallback separately, emit nothing, since
        // visitFallbackEntry will cover it
        if (this.abiFeatures["defines-fallback"]) {
            return "";
        }
        // otherwise, explicitly invoke visitFallbackEntry
        return this.visitFallbackEntry({
            node: { type: "fallback", stateMutability: "payable" },
        });
    }
    visitEventEntry({ node: entry, context }) {
        const { name, inputs, anonymous } = entry;
        return [
            `event ${name}(`,
            inputs.map((node) => (0, visitor_1.dispatch)({
                node,
                visitor: this,
                context: Object.assign(Object.assign({}, context), { parameterModifiers: (parameter) => 
                    // TODO fix this
                    parameter.indexed ? ["indexed"] : [] }),
            })),
            `)`,
            `${anonymous ? "anonymous" : ""};`,
        ].join(" ");
    }
    visitErrorEntry({ node: entry, context }) {
        if (this.versionFeatures["custom-errors"] !== true) {
            throw new Error("ABI defines custom errors; use Solidity v0.8.4 or higher");
        }
        const { name, inputs } = entry;
        return [
            `error ${name}(`,
            inputs.map((node) => (0, visitor_1.dispatch)({
                node,
                visitor: this,
                context: Object.assign(Object.assign({}, context), { parameterModifiers: (parameter) => [] }),
            })),
            `);`,
        ].join(" ");
    }
    visitParameter({ node: parameter, context }) {
        const type = this.generateType(parameter, context);
        // @ts-ignore
        const { parameterModifiers } = context;
        return [type, ...parameterModifiers(parameter), parameter.name].join(" ");
    }
    generateHeader() {
        const includeExperimentalPragma = this.abiFeatures["needs-abiencoder-v2"] &&
            this.versionFeatures["abiencoder-v2"] !== "default";
        const attribution = !this.outputAttribution
            ? []
            : !this.outputSource
                ? [`// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v${package_json_1.version}. !!`]
                : [`// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v${package_json_1.version}. SEE SOURCE BELOW. !!`];
        return [
            `// SPDX-License-Identifier: ${this.license}`,
            ...attribution,
            `pragma solidity ${this.solidityVersion};`,
            ...(includeExperimentalPragma
                ? [`pragma experimental ABIEncoderV2;`]
                : [])
        ].join("\n");
    }
    generateAutogeneratedNotice(abi) {
        if (!this.outputSource) {
            return "";
        }
        return [
            ``,
            `// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:`,
            `/*`,
            JSON.stringify(abi),
            `*/`,
        ].join("\n");
    }
    generateDeclarations() {
        if (this.versionFeatures["structs-in-interfaces"] !== true &&
            Object.keys(this.declarations.signatureDeclarations).length > 0) {
            throw new Error("abi-to-sol does not support custom struct types for this Solidity version");
        }
        const externalContainers = Object.keys(this.declarations.containerSignatures)
            .filter(container => container !== "" && container !== this.name);
        const externalDeclarations = externalContainers
            .map(container => [
            `interface ${container} {`,
            this.generateDeclarationsForContainer(container),
            `}`
        ].join("\n"))
            .join("\n\n");
        const globalSignatures = this.declarations.containerSignatures[""] || [];
        if (globalSignatures.length > 0) {
            const declarations = this.versionFeatures["global-structs"] === true
                ? this.generateDeclarationsForContainer("")
                : [
                    `interface ${shimGlobalInterfaceName} {`,
                    this.generateDeclarationsForContainer(""),
                    `}`
                ].join("\n");
            return [declarations, externalDeclarations].join("\n\n");
        }
        return externalDeclarations;
    }
    generateDeclarationsForContainer(container) {
        const signatures = new Set(this.declarations.containerSignatures[container]);
        if (container === "" && this.versionFeatures["global-structs"] !== true) {
            container = shimGlobalInterfaceName;
        }
        return Object.entries(this.declarations.signatureDeclarations)
            .filter(([signature]) => signatures.has(signature))
            .map(([signature, declaration]) => {
            const { identifier } = this.identifiers[signature];
            const components = this.generateComponents(declaration, { interfaceName: container });
            return `struct ${identifier} { ${components} }`;
        })
            .join("\n\n");
    }
    generateComponents(declaration, context) {
        return declaration.components
            .map((component) => {
            const { name } = component;
            return `${this.generateType(component, context)} ${name};`;
        })
            .join("\n");
    }
    generateType(variable, context = {}) {
        const signature = this.generateSignature(variable);
        if (!signature) {
            return variable.type;
        }
        const { type } = variable;
        const { container, identifier } = this.identifiers[signature];
        if (container && container !== context.interfaceName) {
            return type.replace("tuple", `${container}.${identifier}`);
        }
        if (!container && this.versionFeatures["global-structs"] !== true) {
            return type.replace("tuple", `${shimGlobalInterfaceName}.${identifier}`);
        }
        return type.replace("tuple", identifier);
    }
    generateSignature(variable) {
        if ("signature" in variable && variable.signature) {
            return variable.signature;
        }
        if ("components" in variable && variable.components) {
            return Codec.AbiData.Utils.abiTupleSignature(variable.components);
        }
    }
    generateStateMutability(entry) {
        if (entry.stateMutability && entry.stateMutability !== "nonpayable") {
            return entry.stateMutability;
        }
        return "";
    }
    generateFallbackName() {
        switch (this.versionFeatures["fallback-keyword"]) {
            case true: {
                return "fallback";
            }
            case false: {
                return "function";
            }
            case version_features_1.mixed: {
                throw new Error(`Desired Solidity range lacks unambigious fallback syntax.`);
            }
        }
    }
    generateArrayParameterLocation(parameter) {
        switch (this.versionFeatures["array-parameter-location"]) {
            case undefined: {
                return "";
            }
            case version_features_1.mixed: {
                throw new Error(`Desired Solidity range lacks unambiguous location specifier for ` +
                    `parameter of type "${parameter.type}".`);
            }
            default: {
                return this.versionFeatures["array-parameter-location"];
            }
        }
    }
    generateInterface(abi) {
        return [
            `interface ${this.name} {`,
            this.generateDeclarationsForContainer(this.name),
            ``,
            ...abi.map((node) => (0, visitor_1.dispatch)({
                node,
                context: { interfaceName: this.name },
                visitor: this
            })),
            `}`,
        ].join("\n");
    }
}
//# sourceMappingURL=solidity.js.map

/***/ }),

/***/ 91727:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forRange = exports.allFeatures = exports.mixed = void 0;
const semver = __importStar(__webpack_require__(414866));
exports.mixed = Symbol();
exports.allFeatures = {
    "receive-keyword": {
        ">=0.6.0": true,
        "<0.6.0": false
    },
    "fallback-keyword": {
        ">=0.6.0": true,
        "<0.6.0": false
    },
    "array-parameter-location": {
        ">=0.7.0": "memory",
        "^0.5.0 || ^0.6.0": "calldata",
        "<0.5.0": undefined
    },
    "abiencoder-v2": {
        ">=0.8.0": "default",
        "<0.8.0": "experimental",
    },
    "global-structs": {
        ">=0.6.0": true,
        "<0.6.0": false
    },
    "structs-in-interfaces": {
        ">=0.5.0": true,
        "<0.5.0": false
    },
    "custom-errors": {
        ">=0.8.4": true,
        "<0.8.4": false
    },
    "user-defined-value-types": {
        ">=0.8.8": true,
        "<0.8.8": false
    }
};
const forRange = (range) => {
    const forCategory = (category) => {
        const options = exports.allFeatures[category];
        const matchingRanges = Object.keys(options)
            .filter(optionRange => semver.intersects(range, optionRange));
        if (matchingRanges.length > 1) {
            return exports.mixed;
        }
        const [matchingRange] = matchingRanges;
        return options[matchingRange];
    };
    return Object.keys(exports.allFeatures)
        .map((category) => ({ [category]: forCategory(category) }))
        .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
};
exports.forRange = forRange;
//# sourceMappingURL=version-features.js.map

/***/ }),

/***/ 980817:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dispatch = void 0;
const Abi = __importStar(__webpack_require__(207651));
const dispatch = (options) => {
    const { node, visitor, context } = options;
    if (isAbi(node)) {
        return visitor.visitAbi({
            node: Abi.normalize(node),
            context,
        });
    }
    if (isEntry(node)) {
        switch (node.type) {
            case "function":
                return visitor.visitFunctionEntry({ node, context });
            case "constructor":
                return visitor.visitConstructorEntry({ node, context });
            case "fallback":
                return visitor.visitFallbackEntry({ node, context });
            case "receive":
                return visitor.visitReceiveEntry({ node, context });
            case "event":
                return visitor.visitEventEntry({ node, context });
            case "error":
                return visitor.visitErrorEntry({ node, context });
        }
    }
    return visitor.visitParameter({ node, context });
};
exports.dispatch = dispatch;
const isAbi = (node) => node instanceof Array;
const isEntry = (node) => typeof node === "object" &&
    "type" in node &&
    ["function", "constructor", "fallback", "receive", "event", "error"].includes(node.type) &&
    (node.type !== "function" || "stateMutability" in node || "constant" in node);
//# sourceMappingURL=visitor.js.map

/***/ }),

/***/ 997973:
/***/ ((module) => {

module.exports = JSON.parse('{"name":"abi-to-sol","version":"0.6.2","description":"Compile ABI JSON to Solidity interface","main":"dist/src/index.js","types":"dist/src/index.d.ts","bin":{"abi-to-sol":"dist/bin/abi-to-sol.js"},"files":["dist"],"author":"g. nicholas d\'andrea <nick@gnidan.org>","license":"MIT","scripts":{"abi-to-sol":"ts-node ./bin/abi-to-sol.ts","prepare":"tsc","test":"jest src/**","test:test":"jest test/**","test:dist":"yarn prepare && jest dist/src","test:dist:test":"yarn prepare && jest dist/test"},"homepage":"https://github.com/gnidan/abi-to-sol#readme","repository":{"type":"git","url":"https://github.com/gnidan/abi-to-sol.git","directory":"packages/abi-to-sol"},"devDependencies":{"@types/faker":"^5.1.2","@types/jest":"^26.0.14","@types/jest-json-schema":"^2.1.2","@types/prettier":"^2.1.1","@types/semver":"^7.3.7","change-case":"^4.1.1","faker":"^5.1.0","fast-check":"^2.4.0","husky":">=4","jest":"^26.4.2","jest-fast-check":"^0.0.1","jest-json-schema":"^2.1.0","lint-staged":">=10","solc":"^0.8.6","ts-jest":"^26.4.0","ts-node":"^9.0.0","typescript":"4.5.2"},"dependencies":{"@truffle/abi-utils":"^0.2.2","@truffle/codec":"^0.13.2","@truffle/contract-schema":"^3.3.1","ajv":"^6.12.5","better-ajv-errors":"^0.8.2","neodoc":"^2.0.2","semver":"^7.3.5","source-map-support":"^0.5.19"},"optionalDependencies":{"prettier":"^2.1.2","prettier-plugin-solidity":"1.0.0-alpha.59"},"husky":{"hooks":{"pre-commit":"lint-staged"}},"lint-staged":{"*.{ts,js,css,md}":"prettier --write"},"gitHead":"d0d3ce7bd91d57b5fad19786a9f78d385f4e380e"}');

/***/ })

};
;
//# sourceMappingURL=1324.bundled.js.map