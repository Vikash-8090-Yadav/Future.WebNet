#!/usr/bin/env node

exports.id = 4986;
exports.ids = [4986];
exports.modules = {

/***/ 327073:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 327073;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 334763:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { bundled, core } = (__webpack_require__(64146).info)();
const OS = __webpack_require__(822037);
const analytics = __webpack_require__(795614);
const { extractFlags } = __webpack_require__(54708); // contains utility methods
const globalCommandOptions = __webpack_require__(467023);
const debugModule = __webpack_require__(615158);
const debug = debugModule("core:command:run");
const commands = __webpack_require__(291874);

// this function takes an object with an array of input strings, an options
// object, and a boolean determining whether we allow inexact matches for
// command names - it returns an object with the command name, the run method,
// and the command's meta object containing help and command description
const getCommand = ({ inputStrings, options, noAliases }) => {
  if (inputStrings.length === 0) {
    return null;
  }

  const firstInputString = inputStrings[0];
  let chosenCommand = null;

  // If the command wasn't specified directly, go through a process
  // for inferring the command.
  if (commands.includes(firstInputString)) {
    chosenCommand = firstInputString;
  } else if (noAliases !== true) {
    let currentLength = 1;
    const availableCommandNames = commands;

    // Loop through each letter of the input until we find a command
    // that uniquely matches.
    while (currentLength <= firstInputString.length) {
      // Gather all possible commands that match with the current length
      const possibleCommands = availableCommandNames.filter(possibleCommand => {
        return (
          possibleCommand.substring(0, currentLength) ===
          firstInputString.substring(0, currentLength)
        );
      });

      // Did we find only one command that matches? If so, use that one.
      if (possibleCommands.length === 1) {
        chosenCommand = possibleCommands[0];
        break;
      }
      currentLength += 1;
    }
  }

  if (chosenCommand == null) {
    return null;
  }

  // determine whether Truffle is being run from the bundle or from ./cli.js
  // and require commands accordingly
  let command;
  if (true) {
    const path = __webpack_require__(371017);
    const filePath = path.join(__dirname, `${chosenCommand}.bundled.js`);
    // we need to use this library to bypass webpack's require which can't
    // access the user's filesystem
    const originalRequire = __webpack_require__(344516);
    command = originalRequire(filePath);
  } else {}

  // several commands have a help property that is a function
  if (typeof command.meta.help === "function") {
    command.meta.help = command.meta.help(options);
  }

  return {
    name: chosenCommand,
    run: command.run,
    meta: command.meta
  };
};

// takes an object containing the command (name, run method, and meta object),
// the array of strings that were input, and an options object - it sanitizes
// the input options, merges it with the input options, and returns the result
const prepareOptions = ({ command, inputStrings, options }) => {
  const yargs = __webpack_require__(564968)();
  yargs.command(__webpack_require__(736219)(`./${command.name}/meta`));
  const commandOptions = yargs.parse(inputStrings);

  // remove the task name itself put there by yargs
  if (commandOptions._) commandOptions._.shift();

  // some options might throw if options is a Config object
  // if so, let's ignore those values
  const clone = {};
  Object.keys(options).forEach(key => {
    try {
      clone[key] = options[key];
    } catch {
      // do nothing with values that throw
    }
  });

  // method `extractFlags(args)` : Extracts the `--option` flags from arguments
  const inputOptions = extractFlags(inputStrings);

  // adding allowed global options as enumerated in each command
  const allowedGlobalOptions = command.meta.help.allowedGlobalOptions
    .filter(tag => tag in globalCommandOptions)
    .map(tag => globalCommandOptions[tag]);

  const allValidOptions = [
    ...command.meta.help.options,
    ...allowedGlobalOptions
  ];

  const validOptions = allValidOptions.reduce((a, item) => {
    // we split the options off from the arguments
    // and then we split to handle options of the form --<something>|-<s>
    let options = item.option.split(" ")[0].split("|");
    return [
      ...a,
      ...options.filter(
        option => option.startsWith("--") || option.startsWith("-")
      )
    ];
  }, []);

  let invalidOptions = inputOptions.filter(opt => !validOptions.includes(opt));

  // TODO: Remove exception for 'truffle run' when plugin options support added.
  if (invalidOptions.length > 0 && command.name !== "run") {
    if (options.logger) {
      const log = options.logger.log || options.logger.debug;
      log(
        "> Warning: possible unsupported (undocumented in help) command line option(s): " +
          invalidOptions
      );
    }
  }

  return {
    ...clone,
    ...commandOptions
  };
};

const runCommand = async function (command, options) {
  try {
    // migrate Truffle data to the new location if necessary
    const configMigration = __webpack_require__(199043);
    await configMigration.migrateTruffleDataIfNecessary();
  } catch (error) {
    debug("Truffle data migration failed: %o", error);
  }

  analytics.send({
    command: command.name ? command.name : "other",
    args: options._,
    version: bundled || "(unbundled) " + core
  });

  const unhandledRejections = new Map();

  process.on("unhandledRejection", (reason, promise) => {
    unhandledRejections.set(promise, reason);
  });

  process.on("rejectionHandled", promise => {
    unhandledRejections.delete(promise);
  });

  process.on("exit", _ => {
    const log = options.logger
      ? options.logger.log || options.logger.debug
      : console.log;
    if (unhandledRejections.size) {
      log("UnhandledRejections detected");
      unhandledRejections.forEach((reason, promise) => {
        log(promise, reason);
      });
    }
  });

  return await command.run(options);
};

const displayGeneralHelp = () => {
  const yargs = __webpack_require__(564968)();
  commands.forEach(command => {
    yargs.command(__webpack_require__(736219)(`./${command}/meta`));
  });
  yargs
    .usage(
      "Truffle v" +
        (bundled || core) +
        " - a development framework for Ethereum" +
        OS.EOL +
        OS.EOL +
        "Usage: truffle <command> [options]"
    )
    .epilog("See more at http://trufflesuite.com/docs")
    .showHelp();
};

module.exports = {
  displayGeneralHelp,
  getCommand,
  prepareOptions,
  runCommand
};


/***/ }),

/***/ 462571:
/***/ ((module) => {

module.exports = {
  command: "build",
  description: "Execute build pipeline (if configuration present)",
  builder: {},
  help: {
    usage: "truffle build",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 291874:
/***/ ((module) => {

module.exports = [
  "build",
  "compile",
  "config",
  "console",
  "create",
  "dashboard",
  "db",
  "debug",
  "deploy",
  "develop",
  "exec",
  "help",
  "init",
  "install",
  "migrate",
  "networks",
  "obtain",
  "opcode",
  "preserve",
  "publish",
  "run",
  "test",
  "unbox",
  "version",
  "watch"
];


/***/ }),

/***/ 553051:
/***/ ((module) => {

module.exports = {
  command: "compile",
  description: "Compile contract source files",
  builder: {
    all: {
      type: "boolean",
      default: false
    },
    compiler: {
      type: "string",
      default: null
    },
    list: {
      type: "string"
    },
    help: {
      type: "boolean",
      default: "false"
    }
  },
  help: {
    usage:
      "truffle compile [<source1> <source2>...] [--list <filter>] [--all] [--quiet]",
    options: [
      {
        option: "--all",
        description:
          "Compile all contracts instead of only the contracts changed since last compile."
      },
      {
        option: "--list <filter>",
        description:
          "List all recent stable releases from solc-bin.  If filter is specified then it will display only " +
          "that\n                    type of release or docker tags. The filter parameter must be one of the following: " +
          "prereleases,\n                    releases, latestRelease or docker."
      },
      {
        option: "--compiler <compiler-name>",
        description:
          "Specify a single compiler to use (e.g. `--compiler=solc`). Specify `none` to skip compilation."
      },
      {
        option: "--save-intermediate <output-file>",
        internal: true,
        description:
          "Save the raw compiler results into <output-file>, overwriting any existing content."
      }
    ],
    allowedGlobalOptions: ["config", "quiet"]
  }
};


/***/ }),

/***/ 624722:
/***/ ((module) => {

module.exports = {
  command: "config",
  description: "Set user-level configuration options",
  help: {
    usage:
      "truffle config [--enable-analytics|--disable-analytics] [<list>] [[<get|set> <key>] [<value-for-set>]]",
    options: [
      {
        option: "--enable-analytics",
        description: "Enable Truffle to send usage data to Google Analytics."
      },
      {
        option: "--disable-analytics",
        description:
          "Disable Truffle's ability to send usage data to Google Analytics."
      },
      {
        option: "get",
        description: "Get a Truffle config option value."
      },
      {
        option: "set",
        description: "Set a Truffle config option value."
      },
      {
        option: "list",
        description: "List all Truffle config values."
      }
    ],
    allowedGlobalOptions: []
  },
  builder: {
    _: {
      type: "string"
    }
  }
};


/***/ }),

/***/ 721288:
/***/ ((module) => {

module.exports = {
  command: "console",
  description:
    "Run a console with contract abstractions and commands available",
  builder: {
    url: {
      describe: "Use specified URL for provider",
      type: "string"
    }
  },
  help: {
    usage:
      "truffle console [--verbose-rpc] [--require|-r <file>] [--network <network>|--url <provider_url>]",
    options: [
      {
        option: "--url",
        description:
          "Creates a provider using the given url and connects to the network. This can be used outside of a Truffle project."
      },
      {
        option: "--network",
        description:
          "The network to connect to, as specified in the Truffle config."
      },
      {
        option: "--verbose-rpc",
        description:
          "Log communication between Truffle and the Ethereum client."
      },
      {
        option: "--require|-r <file>",
        description:
          "Preload console environment from required JavaScript " +
          "file. The default export must be an object with named keys that " +
          "will be used\n                    to populate the console environment."
      },
      {
        option: "--require-none",
        description:
          "Do not load any user-defined JavaScript into the " +
          "console environment. This option takes precedence over --require, " +
          "-r, and\n                    values provided for console.require " +
          "in your project's truffle-config.js."
      }
    ],
    // The 'network' option is excluded from here and added manually above as a workaround to combine its usage
    // instructions with url to show that they are mutually exclusive.
    allowedGlobalOptions: ["config"]
  }
};


/***/ }),

/***/ 646038:
/***/ ((module) => {

module.exports = {
  command: "create",
  description: "Helper to create new contracts, migrations and tests",
  builder: {
    all: {
      type: "boolean",
      default: false
    },
    force: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle create <artifact_type> <ArtifactName>",
    options: [
      {
        option: "<artifact_type>",
        description:
          "Create a new artifact where artifact_type is one of the following: " +
          "contract, migration,\n                    test or all. The new artifact is created " +
          "along with one (or all) of the following\n                    files: `contracts/ArtifactName.sol`, " +
          "`migrations/####_artifact_name.js` or\n                    `tests/artifact_name.js`. (required)"
      },
      {
        option: "<ArtifactName>",
        description: "Name of new artifact. (required)"
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 399608:
/***/ ((module) => {

module.exports = {
  command: "dashboard",
  description:
    "Start Truffle Dashboard to sign development transactions using browser wallet",
  builder: {
    port: {
      describe: "Specify the port to start the dashboard and RPC endpoint on",
      type: "number"
    },
    host: {
      describe: "Specify the host to start the dashboard and RPC endpoint on",
      type: "string"
    },
    verbose: {
      describe: "Display debug logs for the dashboard server and message bus",
      type: "boolean"
    }
  },
  help: {
    usage: "truffle dashboard [--port <number>] [--host <string>] [--verbose]",
    options: [
      {
        option: "--port <number>",
        description: "Start the dashboard and RPC endpoint on a specific port."
      },
      {
        option: "--host <string>",
        description: "Start the dashboard and RPC endpoint on a specific host."
      },
      {
        option: "--verbose",
        description:
          "Log debug information from the Dashboard server and message bus."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 206758:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(750823),
  meta: __webpack_require__(779062)
};


/***/ }),

/***/ 779062:
/***/ ((module) => {

module.exports = {
  command: "query",
  description: "Query @truffle/db",
  builder: {},
  help: {
    usage: "truffle db query <query>",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 750823:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* This command does starts an express derived server that invokes
 * `process.exit()` on SIGINT. As a result there is no need to invoke
 * truffle's own `process.exit()` which is triggered by invoking the `done`
 * callback.
 *
 * Todo: blacklist this command for REPLs
 */
module.exports = async function (argv) {
  const Config = __webpack_require__(120553);
  const { getTruffleDb } = __webpack_require__(570972);
  const Db = getTruffleDb();
  if (Db === null) {
    throw new Error(
      "There was a problem importing Truffle Db. Ensure that you have " +
        "@truffle/db installed."
    );
  }
  const { connect } = Db;

  const config = Config.detect(argv);
  const [_, query] = config._;

  if (!query) {
    throw new Error(
      "Query not provided. Please run `truffle db query <query>`"
    );
  }

  const db = connect(config.db);

  const result = await db.execute(query, {});
  console.log(JSON.stringify(result, null, 2));
};


/***/ }),

/***/ 243405:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(12233),
  meta: __webpack_require__(111297)
};


/***/ }),

/***/ 111297:
/***/ ((module) => {

module.exports = {
  command: "serve",
  description: "Start Truffle's GraphQL UI playground",
  builder: {},
  help: {
    usage: "truffle db serve",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 12233:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* This command does starts an express derived server that invokes
 * `process.exit()` on SIGINT. As a result there is no need to invoke
 * truffle's own `process.exit()` which is triggered by invoking the `done`
 * callback.
 *
 * Todo: blacklist this command for REPLs
 */
module.exports = async function (argv) {
  const Config = __webpack_require__(120553);
  const { getTruffleDb } = __webpack_require__(570972);
  const Db = getTruffleDb();
  if (Db === null) {
    throw new Error(
      "There was a problem importing Truffle Db. Ensure that you have " +
        "@truffle/db installed."
    );
  }
  const { serve } = Db;

  const config = Config.detect(argv);
  const port = (config.db && config.db.port) || 4444;
  const host = (config.db && config.db.host) || "127.0.0.1";

  const { url } = await serve(config.db).listen({ host, port });

  console.log(`ðŸš€ Playground listening at ${url}`);
  console.log(`â„¹  Press Ctrl-C to exit`);

  await new Promise(() => {});
};


/***/ }),

/***/ 150111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(822037);
const serveCommand = __webpack_require__(243405);
const queryCommand = __webpack_require__(206758);

const usage =
  "truffle db <sub-command> [options]" +
  OS.EOL +
  "  Available sub-commands: " +
  OS.EOL +
  "                serve \tStart the GraphQL server";

module.exports = {
  command: "db",
  description: "Database interface commands",
  builder: function (yargs) {
    return yargs
      .command({
        ...serveCommand.run,
        ...serveCommand.meta
      })
      .demandCommand();
  },

  subCommands: {
    serve: {
      help: serveCommand.help,
      description: serveCommand.meta
    },
    query: {
      help: queryCommand.help,
      description: queryCommand.meta
    }
  },

  help: {
    usage,
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 542285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(822037);

module.exports = {
  command: "debug",
  description: "Interactively debug any transaction on the blockchain",
  builder: {
    "url": {
      describe: "Use specified URL for provider",
      type: "string"
    },
    "_": {
      type: "string"
    },
    "fetch-external": {
      describe: "Allow debugging of external contracts",
      alias: "x",
      type: "boolean",
      default: false
    },
    "compile-tests": {
      describe: "Allow debugging of Solidity test contracts",
      type: "boolean",
      default: false
    },
    "compile-all": {
      describe: "Force debugger to compile all contracts for extra safety",
      type: "boolean",
      default: false
    },
    "compile-none": {
      describe: "Force debugger to skip compilation (dangerous!)",
      type: "boolean",
      default: false
    }
  },
  help: {
    usage:
      "truffle debug [<transaction_hash>] [--fetch-external|-x]" +
      OS.EOL +
      "                             [--network <network>|--url <provider_url>]" +
      OS.EOL +
      "                             [--compile-tests|--compile-all|--compile-none]",
    options: [
      {
        option: "<transaction_hash>",
        description:
          "Transaction ID to use for debugging.  Mandatory if --fetch-external is passed."
      },
      {
        option: "--fetch-external|-x",
        description:
          "Allows debugging of external contracts with verified sources."
      },
      {
        option: "--network",
        description:
          "The network to connect to, as specified in the Truffle config."
      },
      {
        option: "--url",
        description:
          "Connects to a specified provider given via URL, ignoring networks in config. This option allows using the debugger outside of a Truffle project."
      },
      {
        option: "--compile-tests",
        description:
          "Allows debugging of Solidity test contracts from the test directory.  Implies --compile-all."
      },
      {
        option: "--compile-all",
        description:
          "Forces the debugger to recompile all contracts even if it detects that it can use the artifacts."
      },
      {
        option: "--compile-none",
        description:
          "Forces the debugger to use artifacts even if it detects a problem.  Dangerous; may cause errors."
      }
    ],
    allowedGlobalOptions: ["config"]
    //although network is an allowed global option, it isn't listed here because listing it here would cause
    //it to be tacked on to the end of usage, which would prevent us from doing the thing above where we
    //combine its usage instructions with url to show that they're mutually exclusive.  so as a workaround
    //we've excluded network from here, and added it manually above.
  }
};


/***/ }),

/***/ 772041:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const migrate = __webpack_require__(601827);

module.exports = {
  command: "deploy",
  description: "(alias for migrate)",
  builder: migrate.builder,
  help: {
    usage:
      "truffle deploy [--reset] [-f <number>] [--compile-all] [--verbose-rpc]",
    options: migrate.meta.help.options,
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 314957:
/***/ ((module) => {

module.exports = {
  command: "develop",
  description: "Open a console with a local development blockchain",
  builder: {
    log: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle develop [--log] [--require|-r <file>]",
    options: [
      {
        option: `--log`,
        description:
          `Start/Connect to a Truffle develop session and log all ` +
          `rpc activity. You will\n                    need to open a ` +
          `different Truffle develop or console session to interact via the repl.`
      },
      {
        option: "--require|-r <file>",
        description:
          "Preload console environment from required JavaScript " +
          "file. The default export must be an object with named keys that " +
          "will be used\n                    to populate the console environment."
      },
      {
        option: "--require-none",
        description:
          "Do not load any user-defined JavaScript into the " +
          "console environment. This option takes precedence over --require, " +
          "-r, and\n                    values provided for console.require " +
          "in your project's truffle-config.js."
      }
    ],
    allowedGlobalOptions: ["config"]
  }
};


/***/ }),

/***/ 781483:
/***/ ((module) => {

module.exports = {
  command: "exec",
  description: "Execute a JS module within this Truffle environment",
  builder: {
    file: {
      type: "string"
    },
    c: {
      type: "boolean",
      default: false
    },
    compile: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle exec <script.js> [--compile]",
    options: [
      {
        option: "<script.js>",
        description:
          "JavaScript file to be executed. Can include path information if the script" +
          " does not exist in the current\n                    directory. (required)"
      },
      {
        option: "--compile",
        description: "Compile contracts before executing the script."
      }
    ],
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 634914:
/***/ ((module) => {

module.exports = {
  command: "help",
  description:
    "List all commands or provide information about a specific command",
  help: {
    usage: "truffle help [<command>]",
    options: [
      {
        option: "<command>",
        description: "Name of the command to display information for."
      }
    ],
    allowedGlobalOptions: []
  },
  builder: {}
};


/***/ }),

/***/ 383193:
/***/ ((module) => {

module.exports = {
  command: "init",
  description: "Initialize new and empty Ethereum project",
  builder: {},
  help: {
    usage: "truffle init [--force]",
    options: [
      {
        option: "--force",
        description:
          "Initialize project in the current directory regardless of its " +
          "state. Be careful, this\n                    will potentially overwrite files " +
          "that exist in the directory."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 472545:
/***/ ((module) => {

module.exports = {
  command: "install",
  description: "Install a package from the Ethereum Package Registry",
  builder: {},
  help: {
    usage: "truffle install <package_name>[@<version>]",
    options: [
      {
        option: "package_name",
        description:
          "Name of the package as listed in the Ethereum Package Registry. (required)"
      },
      {
        option: "<@version>",
        description:
          "When specified, will install a specific version of the package, otherwise " +
          "will install\n                    the latest version."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 883292:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Ganache = __webpack_require__(711651);

module.exports = function (config, options) {
  //note: this is a list of chain IDs but we're still using
  //network ID.  This should be fixed later.
  const supportedChainIds = Ganache.__experimental_info().fork.knownChainIds;

  let dryRunOnly, skipDryRun;
  const networkSettingsInConfig = config.networks[config.network];
  if (networkSettingsInConfig) {
    dryRunOnly =
      options.dryRun === true ||
      networkSettingsInConfig.dryRun === true ||
      networkSettingsInConfig["dry-run"] === true;
    skipDryRun =
      options.skipDryRun === true ||
      networkSettingsInConfig.skipDryRun === true ||
      networkSettingsInConfig["skip-dry-run"] === true;
  } else {
    dryRunOnly = options.dryRun === true;
    skipDryRun = options.skipDryRun === true;
  }
  const production =
    supportedChainIds.includes(parseInt(config.network_id)) ||
    config.production;
  const dryRunAndMigrations = production && !skipDryRun;
  return { dryRunOnly, dryRunAndMigrations };
};


/***/ }),

/***/ 601827:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(152423),
  meta: __webpack_require__(88226),
  runMigrations: __webpack_require__(853983),
  setUpDryRunEnvironmentThenRunMigrations: __webpack_require__(643687),
  determineDryRunSettings: __webpack_require__(883292),
  prepareConfigForRealMigrations: __webpack_require__(97374)
};


/***/ }),

/***/ 88226:
/***/ ((module) => {

module.exports = {
  command: "migrate",
  description: "Run migrations to deploy contracts",
  builder: {
    "reset": {
      type: "boolean",
      default: false
    },
    "compile-all": {
      describe: "Recompile all contracts",
      type: "boolean",
      default: false
    },
    "compile-none": {
      describe: "Do not compile contracts",
      type: "boolean",
      default: false
    },
    "dry-run": {
      describe: "Run migrations against an in-memory fork, for testing",
      type: "boolean",
      default: false
    },
    "skip-dry-run": {
      describe: "Skip the test or 'dry run' migrations",
      type: "boolean",
      default: false
    },
    "f": {
      describe: "Specify a migration number to run from",
      type: "number"
    },
    "to": {
      describe: "Specify a migration number to run to",
      type: "number"
    },
    "interactive": {
      describe: "Manually authorize deployments after seeing a preview",
      type: "boolean",
      default: false
    },
    "describe-json": {
      describe: "Adds extra verbosity to the status of an ongoing migration",
      type: "boolean",
      default: false
    }
  },
  help: {
    usage:
      "truffle migrate [--reset] [--f <number>] [--to <number>]\n" +
      "                                " + // spacing to align with previous line
      "[--compile-all] [--compile-none] [--verbose-rpc] [--interactive]\n" +
      "                                " + // spacing to align with previous line
      "[--skip-dry-run] [--describe-json] [--dry-run]",
    options: [
      {
        option: "--reset",
        description:
          "Run all migrations from the beginning, instead of running from the last " +
          "completed migration."
      },
      {
        option: "--f <number>",
        description:
          "Run contracts from a specific migration. The number refers to the prefix of " +
          "the migration file."
      },
      {
        option: "--to <number>",
        description:
          "Run contracts to a specific migration. The number refers to the prefix of the migration file."
      },
      {
        option: "--compile-all",
        description:
          "Compile all contracts instead of intelligently choosing which contracts need to " +
          "be compiled."
      },
      {
        option: "--compile-none",
        description: "Do not compile any contracts before migrating."
      },
      {
        option: "--verbose-rpc",
        description:
          "Log communication between Truffle and the Ethereum client."
      },
      {
        option: "--interactive",
        description:
          "Prompt to confirm that the user wants to proceed after the dry run."
      },
      {
        option: "--dry-run",
        description: "Only perform a test or 'dry run' migration."
      },
      {
        option: "--skip-dry-run",
        description: "Do not run a test or 'dry run' migration."
      },
      {
        option: "--describe-json",
        description:
          "Adds extra verbosity to the status of an ongoing migration"
      }
    ],
    allowedGlobalOptions: ["network", "config", "quiet"]
  }
};


/***/ }),

/***/ 97374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (buildDir, options) {
  const Artifactor = __webpack_require__(529463);
  const { Resolver } = __webpack_require__(648511);
  const Migrate = __webpack_require__(523459);
  const { Environment } = __webpack_require__(376765);
  const Config = __webpack_require__(120553);

  let accept = true;

  if (options.interactive) {
    accept = await Migrate.promptToAcceptDryRun();
  }

  if (accept) {
    const config = Config.detect(options);

    config.contracts_build_directory = buildDir;
    config.artifactor = new Artifactor(buildDir);
    config.resolver = new Resolver(config);

    try {
      await Environment.detect(config);
    } catch (error) {
      throw new Error(error);
    }

    config.dryRun = false;
    return {
      preparedConfig: config,
      proceed: true
    };
  } else {
    return { proceed: false };
  }
};


/***/ }),

/***/ 152423:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const WorkflowCompile = __webpack_require__(577135);
  const { Environment } = __webpack_require__(376765);
  const Config = __webpack_require__(120553);
  const determineDryRunSettings = __webpack_require__(883292);
  const prepareConfigForRealMigrations = __webpack_require__(97374);
  const runMigrations = __webpack_require__(853983);
  const setUpDryRunEnvironmentThenRunMigrations = __webpack_require__(643687);
  const tmp = __webpack_require__(336276);
  tmp.setGracefulCleanup();

  const config = Config.detect(options);
  if (config.compileNone || config["compile-none"]) {
    config.compiler = "none";
  }

  const result = await WorkflowCompile.compileAndSave(config);
  await WorkflowCompile.assignNames(config, result);
  await Environment.detect(config);

  const { dryRunOnly, dryRunAndMigrations } = determineDryRunSettings(
    config,
    options
  );

  if (dryRunOnly) {
    config.dryRun = true;
    await setUpDryRunEnvironmentThenRunMigrations(config);
  } else if (dryRunAndMigrations) {
    const currentBuild = config.contracts_build_directory;
    config.dryRun = true;

    await setUpDryRunEnvironmentThenRunMigrations(config);

    const { preparedConfig, proceed } = await prepareConfigForRealMigrations(
      currentBuild,
      options
    );
    if (proceed) await runMigrations(preparedConfig);
  } else {
    await runMigrations(config);
  }
};


/***/ }),

/***/ 853983:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Migrate = __webpack_require__(523459);

module.exports = async function (config) {
  if (config.f) {
    return await Migrate.runFrom(config.f, config);
  } else {
    const needsMigrating = await Migrate.needsMigrating(config);

    if (needsMigrating) {
      return await Migrate.run(config);
    } else {
      config.logger.log("Network up to date.");
    }
  }
};


/***/ }),

/***/ 643687:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Environment } = __webpack_require__(376765);
const Artifactor = __webpack_require__(529463);

const { Resolver } = __webpack_require__(648511);
const fse = __webpack_require__(655674);

const tmp = __webpack_require__(336276);
tmp.setGracefulCleanup();
const runMigrations = __webpack_require__(853983);

module.exports = async function (config) {
  await Environment.fork(config, {
    logging: {
      quiet: true
    },
    // we need to tell Ganache to not unlock any accounts so that only
    // user's accounts are unlocked since this will be a dry run
    wallet: {
      totalAccounts: 0
    }
  });
  // Copy artifacts to a temporary directory
  const temporaryDirectory = tmp.dirSync({
    unsafeCleanup: true,
    prefix: "migrate-dry-run-"
  }).name;

  fse.copySync(config.contracts_build_directory, temporaryDirectory);

  config.contracts_build_directory = temporaryDirectory;
  // Note: Create a new artifactor and resolver with the updated config.
  // This is because the contracts_build_directory changed.
  // Ideally we could architect them to be reactive of the config changes.
  config.artifactor = new Artifactor(temporaryDirectory);
  config.resolver = new Resolver(config);

  return await runMigrations(config);
};


/***/ }),

/***/ 741873:
/***/ ((module) => {

module.exports = {
  command: "networks",
  description: "Show addresses for deployed contracts on each network",
  builder: {
    clean: {
      describe:
        "Remove network artifacts that don't belong to any configuration",
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle networks [--clean]",
    options: [
      {
        option: "--clean",
        description:
          "Remove all network artifacts that aren't associated with a named network."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 719518:
/***/ ((module) => {

module.exports = {
  command: "obtain",
  description: "Fetch and cache a specified compiler",
  help: {
    usage: "truffle obtain [--solc <version>]",
    options: [
      {
        option: "--solc <version>",
        description: `Download and cache a version of the solc compiler. (required)`
      }
    ],
    allowedGlobalOptions: ["quiet"]
  }
};


/***/ }),

/***/ 103697:
/***/ ((module) => {

module.exports = {
  command: "opcode",
  description: "Print the compiled opcodes for a given contract",
  builder: {
    all: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle opcode <contract_name>",
    options: [
      {
        option: "<contract_name>",
        description:
          "Name of the contract to print opcodes for. Must be a contract name, not a file name. (required)"
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 639175:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  command: "preserve",
  description:
    "Save data to decentralized storage platforms like IPFS and Filecoin",
  help: options => {
    const TruffleError = __webpack_require__(673321);
    const { Plugins } = __webpack_require__(342113);
    const { getConfig } = __webpack_require__(361914);
    const semver = __webpack_require__(627029);

    if (!semver.satisfies(process.version, ">=12")) {
      throw new TruffleError(
        `The current version of Node (${process.version}) does not support \`truffle preserve\`, please update to Node >=12`
      );
    }

    const config = getConfig(options);

    const recipes = Plugins.listAllRecipes(config);

    // If a recipe does not define a tag, it is not an end-user recipe
    const recipeFlags = recipes
      .filter(recipe => recipe.tag !== undefined)
      .map(recipe => ({
        option: `--${recipe.tag}`,
        description: recipe.loadRecipe().help
      }));

    const flags = [
      {
        option: "--environment",
        description:
          "Environment name, as defined in truffle-config `environments` object"
      },
      ...recipeFlags
    ];

    return {
      usage:
        "truffle preserve [--environment=<environment>] <target-path>... --<recipe-tag>",
      options: flags,
      allowedGlobalOptions: []
    };
  }
};


/***/ }),

/***/ 361914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Config = __webpack_require__(120553);

const getConfig = options => {
  let config;
  try {
    config = Config.detect(options);
  } catch (_) {
    config = Config.default().with(options);
  }

  config.plugins = config.plugins || [];
  return config;
};

const constructRecipes = (plugins, environment) => {
  return plugins.map(plugin => {
    const options = (environment || {})[plugin.tag] || {};
    const Recipe = plugin.loadRecipe();
    const recipe = new Recipe(options);
    return recipe;
  });
};

module.exports = {
  getConfig,
  constructRecipes
};


/***/ }),

/***/ 939662:
/***/ ((module) => {

module.exports = {
  command: "publish",
  description: "Publish a package to the Ethereum Package Registry",
  builder: {},
  help: {
    usage: "truffle publish",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 952068:
/***/ ((module) => {

module.exports = {
  command: "run",
  description: "Run a third-party command",
  builder: {},
  help: {
    usage: "truffle run [<command>]",
    options: [
      {
        option: "<command>",
        description: "Name of the third-party command to run."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 43059:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(822037);

module.exports = {
  command: "test",
  description: "Run JavaScript and Solidity tests",
  builder: {
    "show-events": {
      describe: "Show all test logs",
      type: "boolean",
      default: false
    },
    "compile-all-debug": {
      describe: "Compile in debug mode",
      type: "boolean",
      default: false
    },
    "debug": {
      describe: "Enable in-test debugging",
      type: "boolean",
      default: false
    },
    "debug-global": {
      describe: "Specify debug global function name",
      default: "debug"
    },
    "runner-output-only": {
      describe: "Suppress all output except for test runner output.",
      type: "boolean",
      default: false
    },
    "bail": {
      alias: "b",
      describe: "Bail after first test failure",
      type: "boolean",
      default: false
    },
    "stacktrace": {
      alias: "t",
      describe: "Produce Solidity stacktraces",
      type: "boolean",
      default: false
    },
    "stacktrace-extra": {
      describe: "Produce Solidity stacktraces and compile in debug mode",
      type: "boolean",
      default: false
    },
    "reporter": {
      alias: "r",
      describe: "Specify the type of mocha reporter",
      default: undefined
    }
  },
  help: {
    usage:
      `truffle test [<test_file>] [--compile-all[-debug]] [--compile-none] ` +
      `[--migrate-none] ` +
      `[--network <name>]${OS.EOL}                             ` +
      `[--verbose-rpc] [--show-events] [--debug] ` +
      `[--debug-global <identifier>] [--bail|-b]${OS.EOL}                      ` +
      `       [--stacktrace[-extra]] [--grep|-g <regex>] ` +
      `[--reporter|-r <name>] `,
    options: [
      {
        option: "<test_file>",
        description:
          "Name of the test file to be run. Can include path information if the file " +
          "does not exist in the\n                    current directory."
      },
      {
        option: "--compile-all",
        description:
          "Compile all contracts instead of intelligently choosing which contracts need " +
          "to be compiled."
      },
      {
        option: "--compile-none",
        description: "Do not compile any contracts before running the tests"
      },
      {
        option: "--compile-all-debug",
        description:
          "Compile all contracts and do so in debug mode for extra revert info.  May " +
          "cause errors on large\n                    contracts."
      },
      {
        option: "--migrate-none",
        description: "Do not migrate any contracts before running the tests."
      },
      {
        option: "--verbose-rpc",
        description:
          "Log communication between Truffle and the Ethereum client."
      },
      {
        option: "--show-events",
        description: "Log all contract events."
      },
      {
        option: "--debug",
        description:
          "Provides global debug() function for in-test debugging. " +
          "JS tests only; implies --compile-all."
      },
      {
        option: "--debug-global <identifier>",
        description:
          'Specify global identifier for debug function. Default: "debug"'
      },
      {
        option: "--runner-output-only",
        description: "Suppress all output except for test runner output."
      },
      {
        option: "--bail|-b",
        description: "Bail after first test failure."
      },
      {
        option: "--stacktrace",
        description:
          "Allows for mixed JS/Solidity stacktraces when a Truffle Contract transaction " +
          "or deployment\n                    reverts.  Does not apply to calls or gas estimates.  " +
          "Implies --compile-all.  Experimental.  Alias: -t"
      },
      {
        option: "--stacktrace-extra",
        description: "Shortcut for --stacktrace --compile-all-debug."
      },
      {
        option: "--grep|-g",
        description:
          'Use mocha\'s "grep" option while running tests. This ' +
          "option only runs tests that match the supplied regex/string."
      },
      {
        option: "--reporter|-r <name>",
        description:
          "Specify the type of mocha reporter to use during testing. Default: 'spec'"
      }
    ],
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 474292:
/***/ ((module) => {

module.exports = {
  command: "unbox",
  description: "Download a Truffle Box, a pre-built Truffle project",
  builder: {},
  help: {
    usage: "truffle unbox [<box_name>] [destination] [--force]",
    options: [
      {
        option: "destination",
        description:
          "Path to the directory in which you would like " +
          "to unbox the project files. If destination is\n                  " +
          "  not provided, this defaults to the current directory."
      },
      {
        option: "<box_name>",
        description:
          "Name of the truffle box. If no box_name is specified, a default " +
          "truffle box will be downloaded."
      },
      {
        option: "--force",
        description:
          "Unbox project in the current directory regardless of its " +
          "state. Be careful, this\n                    will potentially overwrite files " +
          "that exist in the directory."
      }
    ],
    allowedGlobalOptions: ["quiet"]
  }
};


/***/ }),

/***/ 974770:
/***/ ((module) => {

module.exports = {
  command: "version",
  description: "Show version number and exit",
  builder: {},
  help: {
    usage: "truffle version",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 847766:
/***/ ((module) => {

module.exports = {
  command: "watch",
  description:
    "Watch filesystem for changes and rebuild the project automatically",
  builder: {},
  help: {
    usage: "truffle watch",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 199043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(822037);
const path = __webpack_require__(371017);
const fse = __webpack_require__(655674);
const Conf = __webpack_require__(719658);
const TruffleConfig = __webpack_require__(120553);
const debugModule = __webpack_require__(615158);
const debug = debugModule("core:config-migration");

const CURRENT_CONFIG_VERSION = 1;

module.exports = {
  oldTruffleDataDirectory: path.join(OS.homedir(), ".config", "truffle"),

  needsMigrated: function () {
    const conf = new Conf({ projectName: "truffle" });
    if (conf.get("version") === CURRENT_CONFIG_VERSION) return false;
    const oldConfig = path.join(this.oldTruffleDataDirectory, "config.json");
    if (fse.existsSync(oldConfig) && oldConfig !== conf.path) {
      // we are on Windows or a Mac
      return true;
    } else {
      // we are on Linux or previous config doesn't exist and we don't need to
      // perform a migration - current version set to designates success
      conf.set("version", CURRENT_CONFIG_VERSION);
      return false;
    }
  },

  migrateTruffleDataIfNecessary: async function () {
    if (!this.needsMigrated()) return;
    debug("Truffle files need to be migrated");
    const conf = this.migrateGlobalConfig();
    debug("successfully migrated global config");
    const folders = ["compilers", ".db"];
    for (const folder of folders) {
      await this.migrateFolder(folder);
      debug("successfully migrated folder: %o", folder);
    }
    // set version to current only after migration is complete to designate success
    conf.set("version", CURRENT_CONFIG_VERSION);
  },

  migrateGlobalConfig: function () {
    const conf = new Conf({ projectName: "truffle" });
    const oldSettings = __webpack_require__(518727)(path.join(
      this.oldTruffleDataDirectory,
      "config.json"
    ));
    for (const key in oldSettings) {
      conf.set(key, oldSettings[key]);
    }
    return conf;
  },

  migrateFolder: async function (folderName) {
    const targetPath = path.join(this.oldTruffleDataDirectory, folderName);
    // use conf to determine the new Truffle folder as it uses OS-appropriate locations
    const conf = new Conf({ projectName: "truffle" });
    const destinationPath = path.join(TruffleConfig.getTruffleDataDirectory(), folderName);
    if (fse.existsSync(targetPath)) {
      fse.copySync(targetPath, destinationPath);
    }
  }
};


/***/ }),

/***/ 467023:
/***/ ((module) => {

const options = {
  network: {
    option: "--network <name>",
    description:
      "Specify the network to use. Network name must exist in the configuration."
  },
  config: {
    option: "--config <file>",
    description:
      "Specify configuration file to be used. The default is truffle-config.js"
  },
  quiet: {
    option: "--quiet",
    description: "Suppress excess logging output."
  }
};
module.exports = options;


/***/ }),

/***/ 795614:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Config = __webpack_require__(120553);

const analytics = {
  send: function(eventObject) {
    const userConfig = Config.getUserConfig();

    if (!userConfig.get("enableAnalytics")) {
      // don't bother with creating a new process if we already
      // know the user doesn't want to send analytics
      return;
    }

    let analyticsPath;
    const path = __webpack_require__(371017);
    if (true) {
      analyticsPath = path.join(__dirname, "analytics.bundled.js");
    } else {}

    const cp = __webpack_require__(532081);
    const child = cp.fork(analyticsPath, { silent: true });
    child.send(eventObject);
  }
};

module.exports = analytics;


/***/ }),

/***/ 54708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Extracts the input flags --option from the arguments  of type `--option=value` or `--option value` or `--flag`
const extractFlags = inputArguments => {
  // Get all the args that begins with `--`. This also includes `--option=value`
  const inputFlags = inputArguments.filter(flag => {
    return flag.startsWith("--") ? flag : null;
  });

  // Extract only the flags i.e `--option` from `--option=value`
  inputFlags.map((flag, i) => {
    let indexOfEqualsSign = flag.indexOf("=");
    if (indexOfEqualsSign > 0) {
      flag = flag.slice(0, indexOfEqualsSign);
      inputFlags.splice(i, 1, flag);
    }
  });
  return inputFlags;
};

const detectConfigOrDefault = options => {
  const Config = __webpack_require__(120553);

  try {
    return Config.detect(options);
  } catch (error) {
    // Suppress error when truffle can't find a config
    if (error.message === "Could not find suitable configuration file.") {
      return Config.default();
    } else {
      throw error;
    }
  }
};

module.exports = { extractFlags, detectConfigOrDefault };


/***/ }),

/***/ 64146:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const pkg = __webpack_require__(373755);
const { CompilerSupplier } = __webpack_require__(4273);
const Config = __webpack_require__(120553);

const info = config => {
  let bundleVersion;
  // NOTE: Webpack will replace BUNDLE_VERSION with a string.
  if (true) bundleVersion = "5.5.21";

  let supplierOptions;
  if (config && config.compilers) {
    supplierOptions = {
      events: config.events,
      solcConfig: config.compilers.solc
    };
  } else {
    const { events, compilers } = new Config();
    const solcConfig = compilers.solc;
    supplierOptions = { events, solcConfig };
  }
  const supplier = new CompilerSupplier(supplierOptions);

  return {
    core: pkg.version,
    bundle: bundleVersion,
    solc: supplier.version
  };
};

const logTruffle = (logger = console, versionInformation) => {
  const bundle = versionInformation.bundle
    ? `v${versionInformation.bundle}`
    : "(unbundled)";
  logger.log(`Truffle ${bundle} (core: ${versionInformation.core})`);
};

const logNode = (logger = console) => {
  logger.log(`Node ${process.version}`);
};

const logSolidity = (logger = console, versionInformation, config) => {
  let solcVersion;
  if (
    config &&
    config.compilers &&
    config.compilers.solc &&
    config.compilers.solc.version
  ) {
    solcVersion = config.compilers.solc.version;
    logger.log(`Solidity - ${solcVersion} (solc-js)`);
  } else {
    const versionInformation = info(config);
    solcVersion = versionInformation.solc;
    logger.log(`Solidity v${solcVersion} (solc-js)`);
  }
};

const logWeb3 = (logger = console) => {
  const web3Version = pkg.dependencies.web3;
  logger.log(`Web3.js v${web3Version}`);
};

const logGanache = (logger = console) => {
  const ganacheVersion = pkg.dependencies.ganache;
  logger.log(`Ganache v${ganacheVersion}`);
};

const logAll = (logger = console, config) => {
  const versionInformation = info(config);
  logTruffle(logger, versionInformation);
  logGanache(logger);
  logSolidity(logger, versionInformation, config);
  logNode(logger);
  logWeb3(logger);
};

const logTruffleAndNode = (logger = console, config) => {
  const versionInformation = info(config);
  logTruffle(logger, versionInformation);
  logNode(logger);
};

module.exports = {
  logAll,
  info,
  logTruffleAndNode
};


/***/ }),

/***/ 386927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { IPC } = __webpack_require__(775898);
const path = __webpack_require__(371017);
const { spawn } = __webpack_require__(532081);
const debug = __webpack_require__(615158);

const Develop = {
  start: async function (ipcNetwork, options = {}) {
    let chainPath;

    // The path to the dev env process depends on whether or not
    // we're running in the bundled version. If not, use chain.js
    // directly, otherwise let the bundle point at the bundled version.
    if (true) {
      // Remember: In the bundled version, __dirname refers to the
      // build directory where cli.bundled.js and cli.chain.js live.
      chainPath = path.join(__dirname, "chain.bundled.js");
    } else {}

    const logger = options.logger || console;
    //check that genesis-time config option passed through the truffle-config.js file is a valid time.
    if (options.time && isNaN(Date.parse(options.time))) {
      options.time = Date.now();
      logger.log(
        "\x1b[31m%s\x1b[0m",
        "Invalid Date passed to genesis-time, using current Date instead",
        "\x1b[0m"
      );
    }

    const stringifiedOptions = JSON.stringify(options);
    const optionsBuffer = Buffer.from(stringifiedOptions);
    const base64OptionsString = optionsBuffer.toString("base64");

    return spawn("node", [chainPath, ipcNetwork, base64OptionsString], {
      detached: true,
      stdio: "ignore"
    });
  },

  connect: function (options) {
    const debugServer = debug("develop:ipc:server");
    const debugClient = debug("develop:ipc:client");
    const debugRPC = debug("develop:ganache");

    options.retry = options.retry || false;
    options.log = options.log || false;
    options.network = options.network || "develop";
    var ipcNetwork = options.network;

    var ipc = new IPC();
    ipc.config.appspace = "truffle.";

    // set connectPath explicitly
    var dirname = ipc.config.socketRoot;
    var basename = `${ipc.config.appspace}${ipcNetwork}`;
    var connectPath = path.join(dirname, basename);

    ipc.config.silent = !debugClient.enabled;
    ipc.config.logger = debugClient;

    var loggers = {};

    if (debugServer.enabled) {
      loggers.ipc = debugServer;
    }

    if (options.log) {
      debugRPC.enabled = true;

      loggers.ganache = function () {
        // HACK-y: replace `{}` that is getting logged instead of ""
        var args = Array.prototype.slice.call(arguments);
        if (
          args.length === 1 &&
          typeof args[0] === "object" &&
          Object.keys(args[0]).length === 0
        ) {
          args[0] = "";
        }

        debugRPC.apply(undefined, args);
      };
    }

    if (!options.retry) {
      ipc.config.maxRetries = 0;
    }

    var disconnect = function () {
      ipc.disconnect(ipcNetwork);
    };

    return new Promise((resolve, reject) => {
      ipc.connectTo(ipcNetwork, connectPath, function () {
        ipc.of[ipcNetwork].on("destroy", function () {
          reject(new Error("IPC connection destroyed"));
        });

        ipc.of[ipcNetwork].on("truffle.ready", function () {
          resolve(disconnect);
        });

        Object.keys(loggers).forEach(function (key) {
          var log = loggers[key];
          if (log) {
            var message = `truffle.${key}.log`;
            ipc.of[ipcNetwork].on(message, log);
          }
        });
      });
    });
  },

  connectOrStart: async function (options, ganacheOptions) {
    options.retry = false;

    const ipcNetwork = options.network || "develop";

    let started = false;
    let disconnect;

    try {
      disconnect = await this.connect(options);
    } catch (_error) {
      await this.start(ipcNetwork, ganacheOptions);
      options.retry = true;
      disconnect = await this.connect(options);
      started = true;
    } finally {
      return {
        disconnect,
        started
      };
    }
  }
};

module.exports = Develop;


/***/ }),

/***/ 753234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Web3 = __webpack_require__(503283);
const { createInterfaceAdapter } = __webpack_require__(936339);
const expect = __webpack_require__(414096);
const TruffleError = __webpack_require__(673321);
const { Resolver } = __webpack_require__(648511);
const Artifactor = __webpack_require__(529463);
const Ganache = __webpack_require__(711651);
const Provider = __webpack_require__(200509);

const Environment = {
  // It's important config is a Config object and not a vanilla object
  detect: async function (config) {
    expect.options(config, ["networks"]);

    helpers.setUpConfig(config);
    helpers.validateNetworkConfig(config);

    const interfaceAdapter = createInterfaceAdapter({
      provider: config.provider,
      networkType: config.network_config.type
    });

    await Provider.testConnection(config);
    await helpers.detectAndSetNetworkId(config, interfaceAdapter);
    await helpers.setFromOnConfig(config, interfaceAdapter);
  },

  // Ensure you call Environment.detect() first.
  fork: async function (config, ganacheOptions) {
    expect.options(config, ["from", "provider", "networks", "network"]);

    const interfaceAdapter = createInterfaceAdapter({
      provider: config.provider,
      networkType: config.network_config.type
    });

    let accounts;
    try {
      accounts = await interfaceAdapter.getAccounts();
    } catch {
      // don't prevent Truffle from working if user doesn't provide some way
      // to sign transactions (e.g. no reason to disallow debugging)
      accounts = [];
    }
    const block = await interfaceAdapter.getBlock("latest");

    const upstreamNetwork = config.network;
    const upstreamConfig = config.networks[upstreamNetwork];
    const forkedNetwork = config.network + "-fork";
    ganacheOptions = {
      ...ganacheOptions,
      fork: config.provider,
      miner: {
        ...ganacheOptions.miner,
        blockGasLimit: block.gasLimit
      }
    };
    if (accounts.length > 0) ganacheOptions.unlocked_accounts = accounts;

    config.networks[forkedNetwork] = {
      network_id: config.network_id,
      provider: Ganache.provider(ganacheOptions),
      from: config.from,
      gas: upstreamConfig.gas,
      gasPrice: upstreamConfig.gasPrice
    };
    config.network = forkedNetwork;
  },

  develop: async (config, ganacheOptions) => {
    expect.options(config, ["networks"]);

    const network = config.network || "develop";
    const url = `http://${ganacheOptions.host}:${ganacheOptions.port}/`;

    config.networks[network] = {
      ...config.networks[network],
      network_id: ganacheOptions.network_id,
      provider: function () {
        return new Web3.providers.HttpProvider(url, { keepAlive: false });
      }
    };

    config.network = network;

    return await Environment.detect(config);
  }
};

const helpers = {
  setFromOnConfig: async (config, interfaceAdapter) => {
    if (config.from) return;

    try {
      const accounts = await interfaceAdapter.getAccounts();
      config.networks[config.network].from = accounts[0];
    } catch {
      // don't prevent Truffle from working if user doesn't provide some way
      // to sign transactions (e.g. no reason to disallow debugging)
    }
  },

  detectAndSetNetworkId: async (config, interfaceAdapter) => {
    const configNetworkId = config.networks[config.network].network_id;
    const providerNetworkId = await interfaceAdapter.getNetworkId();
    if (configNetworkId !== "*") {
      // Ensure the network id matches the one in the config for safety
      if (providerNetworkId.toString() !== configNetworkId.toString()) {
        const error =
          `The network id specified in the truffle config ` +
          `(${configNetworkId}) does not match the one returned by the network ` +
          `(${providerNetworkId}).  Ensure that both the network and the ` +
          `provider are properly configured.`;
        throw new Error(error);
      }
    } else {
      // We have a "*" network. Get the current network and replace it with the real one.
      // TODO: Should we replace this with the blockchain uri?
      config.networks[config.network].network_id = providerNetworkId;
    }
  },

  validateNetworkConfig: config => {
    const networkConfig = config.network_config;

    if (!networkConfig) {
      throw new TruffleError(
        `Unknown network "${config.network}` +
          `". See your Truffle configuration file for available networks.`
      );
    }

    const configNetworkId = config.network_config.network_id;

    if (configNetworkId == null) {
      throw new Error(
        `You must specify a network_id in your '` +
          `${config.network}' configuration in order to use this network.`
      );
    }
  },

  setUpConfig: config => {
    if (!config.resolver) {
      config.resolver = new Resolver(config);
    }

    if (!config.artifactor) {
      config.artifactor = new Artifactor(config.contracts_build_directory);
    }

    if (!config.network) {
      if (config.networks["development"]) {
        config.network = "development";
      } else {
        config.network = "ganache";
        config.networks[config.network] = {
          host: "127.0.0.1",
          port: 7545,
          network_id: 5777
        };
      }
    }

    const currentNetworkSettings = config.networks[config.network];
    if (
      currentNetworkSettings &&
      currentNetworkSettings.ens &&
      currentNetworkSettings.ens.registry
    ) {
      config.ens.registryAddress = currentNetworkSettings.ens.registry.address;
    }
  }
};

module.exports = Environment;


/***/ }),

/***/ 376765:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Environment = __webpack_require__(753234);
const Develop = __webpack_require__(386927);

module.exports = { Environment, Develop };


/***/ }),

/***/ 736219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./build/meta": 462571,
	"./compile/meta": 553051,
	"./config/meta": 624722,
	"./console/meta": 721288,
	"./create/meta": 646038,
	"./dashboard/meta": 399608,
	"./db/commands/query/meta": 779062,
	"./db/commands/serve/meta": 111297,
	"./db/meta": 150111,
	"./debug/meta": 542285,
	"./deploy/meta": 772041,
	"./develop/meta": 314957,
	"./exec/meta": 781483,
	"./help/meta": 634914,
	"./init/meta": 383193,
	"./install/meta": 472545,
	"./migrate/meta": 88226,
	"./networks/meta": 741873,
	"./obtain/meta": 719518,
	"./opcode/meta": 103697,
	"./preserve/meta": 639175,
	"./publish/meta": 939662,
	"./run/meta": 952068,
	"./test/meta": 43059,
	"./unbox/meta": 474292,
	"./version/meta": 974770,
	"./watch/meta": 847766
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 736219;

/***/ }),

/***/ 518727:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 518727;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 921077:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 921077;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 457372:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 457372;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 826503:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 826503;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 495183:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Plugin = void 0;
const TruffleError = __webpack_require__(673321);
const originalRequire = __webpack_require__(344516);
const path_1 = __importDefault(__webpack_require__(371017));
class Plugin {
    constructor({ module, definition }) {
        this.module = module;
        this.definition = definition;
    }
    /*
     * `truffle run` support
     */
    get commands() {
        return Object.keys(this.definition.commands || {});
    }
    definesCommand(commandName) {
        return this.commands.includes(commandName);
    }
    loadCommand(commandName) {
        const commandLocalPath = this.definition.commands && this.definition.commands[commandName];
        if (!commandLocalPath) {
            throw new TruffleError(`Plugin ${this.module} does not define command ${commandName}`);
        }
        return this.loadModule(commandLocalPath);
    }
    /*
     * `truffle preserve` support
     */
    get tag() {
        return this.definition.tag;
    }
    definesRecipe() {
        return !!(this.definition.preserve && this.definition.preserve.recipe);
    }
    loadRecipe() {
        if (!this.definesRecipe()) {
            throw new TruffleError(`Plugin ${this.module} does not define a \`truffle preserve\` recipe.`);
        }
        return this.loadModule(this.definition.preserve.recipe).Recipe;
    }
    loadModule(localPath) {
        if (path_1.default.isAbsolute(localPath)) {
            throw new TruffleError(`\nError: Absolute paths not allowed!\nPlease ensure truffle-plugin.json only references paths relative to the plugin root.\n`);
        }
        const pluginPath = originalRequire.resolve(this.module);
        const modulePath = path_1.default.resolve(path_1.default.dirname(pluginPath), localPath);
        return originalRequire(modulePath);
    }
}
exports.Plugin = Plugin;
//# sourceMappingURL=Plugin.js.map

/***/ }),

/***/ 108097:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Plugins = void 0;
const TruffleError = __webpack_require__(673321);
const originalRequire = __webpack_require__(344516);
const path_1 = __importDefault(__webpack_require__(371017));
const Plugin_1 = __webpack_require__(495183);
const utils_1 = __webpack_require__(436025);
class Plugins {
    /**
     * Given a truffle-config-like, find and return all configured plugins
     */
    static listAll(config) {
        const plugins = Plugins.checkPluginModules(config);
        const definitions = Plugins.loadPluginDefinitions(plugins);
        return Object.entries(definitions).map(([module, definition]) => new Plugin_1.Plugin({ module, definition }));
    }
    /**
     * Given a truffle-config-like and command, find and return all plugins that define the command
     */
    static findPluginsForCommand(config, command) {
        const allPlugins = Plugins.listAll(config);
        const pluginsForCommand = allPlugins.filter(plugin => plugin.definesCommand(command));
        return pluginsForCommand;
    }
    /**
     * Given a truffle-config-like, find and return all plugins that define any command
     */
    static listAllCommandPlugins(config) {
        const allPlugins = Plugins.listAll(config);
        const pluginsWithCommands = allPlugins.filter(plugin => plugin.commands.length > 0);
        return pluginsWithCommands;
    }
    /**
     * Given a truffle-config-like, find and return all plugins that define a recipe
     */
    static listAllRecipes(config) {
        const allPlugins = Plugins.listAll(config);
        const recipes = allPlugins.filter(plugin => plugin.definesRecipe());
        return recipes;
    }
    /*
     * internals
     */
    static checkPluginModules(config) {
        originalRequire("app-module-path").addPath(path_1.default.resolve(config.working_directory, "node_modules"));
        const plugins = utils_1.normalizeConfigPlugins(config.plugins || []);
        return plugins;
    }
    static loadPluginDefinitions(plugins) {
        let pluginConfigs = {};
        for (const { module, tag } of plugins) {
            try {
                const required = originalRequire(`${module}/truffle-plugin.json`);
                const defaultTag = required.preserve && required.preserve.tag;
                required.tag = tag || defaultTag || undefined;
                pluginConfigs[module] = required;
            }
            catch (_) {
                throw new TruffleError(`\nError: truffle-plugin.json not found in the ${module} plugin package!\n`);
            }
        }
        return pluginConfigs;
    }
}
exports.Plugins = Plugins;
//# sourceMappingURL=Plugins.js.map

/***/ }),

/***/ 342113:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(849094), exports);
__exportStar(__webpack_require__(495183), exports);
__exportStar(__webpack_require__(108097), exports);
__exportStar(__webpack_require__(436025), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 849094:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 436025:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeConfigPlugins = exports.resolves = void 0;
const TruffleError = __webpack_require__(673321);
const originalRequire = __webpack_require__(344516);
/**
 * Returns true or false based on whether or not a particular plugin
 * resolves successfully
 */
const resolves = (module) => {
    try {
        originalRequire.resolve(module);
        return true;
    }
    catch (_) {
        return false;
    }
};
exports.resolves = resolves;
/**
 * Takes a list of raw plugin configurations and returns a list of normalized
 * internal representations
 */
const normalizeConfigPlugins = (plugins) => {
    const map = new Map([]);
    const normalized = plugins.map((plugin) => typeof plugin === "string" ? { module: plugin } : plugin);
    for (const plugin of normalized) {
        // fatal error if we can't load a plugin listed in truffle-config.js
        if (!exports.resolves(plugin.module)) {
            throw new TruffleError(`\nError: ${plugin.module} listed as a plugin, but not found in global or local node modules!\n`);
        }
        map.set(plugin.module, plugin);
    }
    return [...map.values()];
};
exports.normalizeConfigPlugins = normalizeConfigPlugins;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 373755:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@truffle/core","description":"Core code for Truffle command line tool","license":"MIT","author":"consensys.net","homepage":"https://github.com/trufflesuite/truffle#readme","repository":{"type":"git","url":"https://github.com/trufflesuite/truffle.git","directory":"packages/core"},"bugs":{"url":"https://github.com/trufflesuite/truffle/issues"},"version":"5.5.21","bin":{"truffle":"./cli.js","truffle-exec":"./exec.js"},"scripts":{"prepare":"exit 0","test":"mocha ./test/** ./test/**/*"},"dependencies":{"@truffle/artifactor":"^4.0.160","@truffle/box":"^2.1.51","@truffle/codec":"^0.13.2","@truffle/compile-common":"^0.7.32","@truffle/compile-solidity":"^6.0.34","@truffle/config":"^1.3.31","@truffle/contract":"^4.5.16","@truffle/dashboard":"^0.1.8","@truffle/debug-utils":"^6.0.27","@truffle/debugger":"^10.0.17","@truffle/decoder":"^5.2.19","@truffle/deployer":"^3.2.87","@truffle/environment":"^0.2.114","@truffle/error":"^0.1.0","@truffle/expect":"^0.1.1","@truffle/fetch-and-compile":"^0.5.9","@truffle/interface-adapter":"^0.5.18","@truffle/migrate":"^3.3.1","@truffle/plugins":"^0.2.7","@truffle/preserve":"^0.2.7","@truffle/promise-tracker":"^0.1.0","@truffle/provider":"^0.2.56","@truffle/provisioner":"^0.2.54","@truffle/require":"^2.0.100","@truffle/resolver":"^9.0.7","@truffle/source-fetcher":"^1.0.10","@truffle/spinners":"^0.2.0","@truffle/workflow-compile":"^4.0.24","address":"^1.1.2","chai":"^4.2.0","colors":"1.4.0","command-exists":"^1.2.8","conf":"^10.0.2","debug":"^4.3.1","del":"^2.2.0","ethereum-cryptography":"1.0.3","ethereumjs-wallet":"^1.0.1","ethpm":"0.0.19","ethpm-registry":"0.1.0-next.3","fs-extra":"^9.1.0","ganache":"7.2.0","get-port":"^5.1.1","get-random-values":"^1.2.2","glob":"^7.1.6","inquirer":"8.2.2","js-interpreter":"2.2.0","lodash":"^4.17.21","mocha":"9.2.2","node-emoji":"^1.8.1","original-require":"^1.0.1","sane":"^4.0.2","semver":"^7.3.4","source-map-support":"^0.5.19","spawn-args":"0.2.0","tmp":"^0.2.1","universal-analytics":"^0.4.17","web3":"1.7.4","web3-utils":"1.7.4","xregexp":"^4.2.4","yargs":"^13.3.0"},"devDependencies":{"@truffle/blockchain-utils":"^0.1.3","app-module-path":"^2.2.0","chai-as-promised":"^7.1.1","memorystream":"^0.3.1","sinon":"^9.0.2"},"publishConfig":{"access":"public"},"authors":[{"name":"Tim Coulter","email":"tim@trufflesuite.com","url":"https://github.com/tcoulter"}],"namespace":"consensys","gitHead":"0c56592405573ec799bd9a295e4d0c5310f4f532"}');

/***/ })

};
;
//# sourceMappingURL=4986.bundled.js.map