#!/usr/bin/env node

exports.id = 458;
exports.ids = [458];
exports.modules = {

/***/ 900458:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debugModule = __webpack_require__(615158);
const debug = debugModule("lib:debug:cli");

const fs = __webpack_require__(655674);
const path = __webpack_require__(371017);

const Debugger = __webpack_require__(692851);
const DebugUtils = __webpack_require__(93293);
const Codec = __webpack_require__(20102);
const { fetchAndCompileForDebugger } = __webpack_require__(705523);

const { DebugInterpreter } = __webpack_require__(779311);
const { DebugCompiler } = __webpack_require__(455887);

const Spinner = (__webpack_require__(92189).Spinner);

class CLIDebugger {
  constructor(config, { compilations, txHash } = {}) {
    this.config = config;
    this.compilations = compilations;
    this.txHash = txHash;
  }

  async run() {
    this.config.logger.log("Starting Truffle Debugger...");

    const session = await this.connect();

    // initialize prompt/breakpoints/ui logic
    const interpreter = await this.buildInterpreter(session);

    return interpreter;
  }

  async connect() {
    // get compilations (either by shimming compiled artifacts,
    // or by doing a recompile)
    const compilations = this.compilations || (await this.getCompilations());

    // invoke @truffle/debugger
    const session = await this.startDebugger(compilations);

    return session;
  }

  async fetchExternalSources(bugger) {
    const fetchSpinner = new Spinner(
      "core:debug:cli:fetch",
      "Getting and compiling external sources..."
    );
    const {
      fetch: badAddresses,
      fetchers: badFetchers,
      compile: badCompilationAddresses
    } = await fetchAndCompileForDebugger(bugger, this.config); //Note: mutates bugger!!
    if (
      badAddresses.length === 0 &&
      badFetchers.length === 0 &&
      badCompilationAddresses.length === 0
    ) {
      fetchSpinner.succeed();
    } else {
      let warningStrings = [];
      if (badFetchers.length > 0) {
        warningStrings.push(
          `Errors occurred connecting to ${badFetchers.join(", ")}.`
        );
      }
      if (badAddresses.length > 0) {
        warningStrings.push(
          `Errors occurred while getting sources for addresses ${badAddresses.join(
            ", "
          )}.`
        );
      }
      if (badCompilationAddresses.length > 0) {
        warningStrings.push(
          `Errors occurred while compiling sources for addresses ${badCompilationAddresses.join(
            ", "
          )}.`
        );
      }
      // simulate ora's "warn" feature
      fetchSpinner.warn(warningStrings.join("  "));
    }
  }

  async getCompilations() {
    //if compileNone is true and configFileSkiped
    //we understand that user is debugging using --url and does not have a config file
    //so instead of resolving compilations, we return an empty value
    if (this.config.compileNone && this.config.configFileSkipped) {
      return [];
    }

    let artifacts;
    artifacts = await this.gatherArtifacts();
    if ((artifacts && !this.config.compileAll) || this.config.compileNone) {
      let shimmedCompilations =
        Codec.Compilations.Utils.shimArtifacts(artifacts);
      //if they were compiled simultaneously, yay, we can use it!
      //(or if we *force* it to...)
      if (
        this.config.compileNone ||
        shimmedCompilations.every(DebugUtils.isUsableCompilation)
      ) {
        debug("shimmed compilations usable");
        return shimmedCompilations;
      }
      debug("shimmed compilations unusable");
    }
    //if not, or if build directory doesn't exist, we have to recompile
    return await this.compileSources();
  }

  async compileSources() {
    const compileSpinner = new Spinner(
      "core:debug:cli:compile",
      "Compiling your contracts..."
    );

    const compilationResult = await new DebugCompiler(this.config).compile({
      withTests: this.config.compileTests
    });
    debug("compilationResult: %O", compilationResult);

    compileSpinner.succeed();

    return Codec.Compilations.Utils.shimCompilations(compilationResult);
  }

  async startDebugger(compilations) {
    const startMessage = DebugUtils.formatStartMessage(
      this.txHash !== undefined
    );
    let bugger;
    if (!this.config.fetchExternal) {
      //ordinary case, not doing fetch-external
      const startSpinner = new Spinner("core:debug:cli:start", startMessage);
      bugger = await Debugger.forProject({
        provider: this.config.provider,
        compilations
      });
      if (this.txHash !== undefined) {
        try {
          debug("loading %s", this.txHash);
          await bugger.load(this.txHash);
          startSpinner.succeed();
        } catch (_) {
          debug("loading error");
          startSpinner.fail();
          //just start up unloaded
        }
      } else {
        startSpinner.succeed();
      }
    } else {
      //fetch-external case
      //note that in this case we start in light mode
      //and only wake up to full mode later!
      //also, in this case, we can be sure that txHash is defined
      bugger = await Debugger.forTx(this.txHash, {
        provider: this.config.provider,
        compilations,
        lightMode: true
      }); //note: may throw!
      await this.fetchExternalSources(bugger); //note: mutates bugger!
      const startSpinner = new Spinner("core:debug:cli:start", startMessage);
      await bugger.startFullMode();
      //I'm removing the failure check here because I don't think that can
      //actually happen
      startSpinner.succeed();
    }
    return bugger;
  }

  async buildInterpreter(session) {
    return new DebugInterpreter(this.config, session, this.txHash);
  }

  async gatherArtifacts() {
    // Gather all available contract artifacts
    // if build directory doesn't exist, return undefined to signal that
    // a recompile is necessary
    if (!fs.existsSync(this.config.contracts_build_directory)) {
      return undefined;
    }
    const files = fs.readdirSync(this.config.contracts_build_directory);

    let contracts = files
      .filter(filePath => {
        return path.extname(filePath) === ".json";
      })
      .map(filePath => {
        return path.basename(filePath, ".json");
      })
      .map(contractName => {
        return this.config.resolver.require(contractName);
      });

    await Promise.all(
      contracts.map(abstraction => abstraction.detectNetwork())
    );

    return contracts;
  }
}

module.exports = {
  CLIDebugger
};


/***/ }),

/***/ 455887:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const WorkflowCompile = __webpack_require__(577135);
const { Resolver } = __webpack_require__(648511);
const glob = __webpack_require__(312884);
const path = __webpack_require__(371017);

class DebugCompiler {
  constructor(config) {
    this.config = config;
  }

  async compile({ withTests }) {
    let compileConfig = this.config.with({ quiet: true });

    if (withTests) {
      const testResolver = new Resolver(this.config, {
        includeTruffleSources: true
      });
      const testFiles = glob
        .sync(`${this.config.test_directory}/**/*.sol`)
        .map(filePath => path.resolve(filePath));
      compileConfig = compileConfig.with({
        resolver: testResolver,
        //note we only need to pass *additional* files
        files: testFiles
      });
    }

    const { compilations } = await WorkflowCompile.compile(
      compileConfig.with({ all: true })
    );

    return compilations;
  }
}

module.exports = {
  DebugCompiler
};


/***/ }),

/***/ 779311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debugModule = __webpack_require__(615158);
const debug = debugModule("lib:debug:interpreter");

const path = __webpack_require__(371017);
const util = __webpack_require__(473837);

const DebugUtils = __webpack_require__(93293);
const selectors = (__webpack_require__(692851).selectors);
const { session, sourcemapping, stacktrace, trace, evm, controller } =
  selectors;

const analytics = __webpack_require__(795614);
const repl = __webpack_require__(438102);

const { DebugPrinter } = __webpack_require__(429099);

const Spinner = (__webpack_require__(92189).Spinner);

function watchExpressionAnalytics(raw) {
  if (raw.includes("!<")) {
    //don't send analytics for watch expressions involving selectors
    return;
  }
  let expression = raw.trim();
  //legal Solidity identifiers (= legal JS identifiers)
  let identifierRegex = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  let isVariable = expression.match(identifierRegex) !== null;
  analytics.send({
    command: "debug: watch expression",
    args: { isVariable }
  });
}

class DebugInterpreter {
  constructor(config, session, txHash) {
    this.session = session;
    this.network = config.network;
    this.fetchExternal = config.fetchExternal;
    this.printer = new DebugPrinter(config, session);
    this.txHash = txHash;
    this.lastCommand = "n";
    this.enabledExpressions = new Set();
    this.repl = null;
  }

  async setOrClearBreakpoint(args, setOrClear) {
    const breakpoints = this.determineBreakpoints(args); //note: not pure, can print
    if (breakpoints !== null) {
      for (const breakpoint of breakpoints) {
        await this.setOrClearBreakpointObject(breakpoint, setOrClear);
      }
    } else {
      //null is a special value representing all, we'll handle it separately
      if (setOrClear) {
        // only "B all" is legal, not "b all"
        this.printer.print("Cannot add breakpoint everywhere.");
      } else {
        await this.session.removeAllBreakpoints();
        this.printer.print("Removed all breakpoints.");
      }
    }
  }

  //NOTE: not pure, also prints!
  //returns an array of the breakpoints, unless it's remove all breakpoints,
  //in which case it returns null
  //(if something goes wrong it will return [] to indicate do nothing)
  determineBreakpoints(args) {
    const currentLocation = this.session.view(controller.current.location);

    const currentStart = currentLocation.sourceRange
      ? currentLocation.sourceRange.start
      : null;
    const currentLength = currentLocation.sourceRange
      ? currentLocation.sourceRange.length
      : null;
    const currentSourceId = currentLocation.source
      ? currentLocation.source.id
      : null;
    const currentLine =
      currentSourceId !== null && currentSourceId !== undefined
        ? //sourceRange is never null, so we go by whether currentSourceId is null/undefined
          currentLocation.sourceRange.lines.start.line
        : null;

    if (args.length === 0) {
      //no arguments, want currrent node
      debug("node case");
      if (currentSourceId === null) {
        this.printer.print("Cannot determine current location.");
        return [];
      }
      return [
        {
          start: currentStart,
          line: currentLine, //this isn't necessary for the
          //breakpoint to work, but we use it for printing messages
          length: currentLength,
          sourceId: currentSourceId
        }
      ];
    }

    //the special case of "B all"
    else if (args[0] === "all") {
      return null;
    }

    //if the argument starts with a "+" or "-", we have a relative
    //line number
    else if (args[0][0] === "+" || args[0][0] === "-") {
      debug("relative case");
      if (currentLine === null) {
        this.printer.print("Cannot determine current location.");
        return [];
      }
      let delta = parseInt(args[0], 10); //want an integer
      debug("delta %d", delta);

      if (isNaN(delta)) {
        this.printer.print("Offset must be an integer.");
        return [];
      }

      return [
        {
          sourceId: currentSourceId,
          line: currentLine + delta
        }
      ];
    }

    //if it contains a colon, it's in the form source:line
    else if (args[0].includes(":")) {
      debug("source case");
      let sourceArgs = args[0].split(":");
      let sourceArg = sourceArgs[0];
      let lineArg = sourceArgs[1];
      debug("sourceArgs %O", sourceArgs);

      //first let's get the line number as usual
      let line = parseInt(lineArg, 10); //want an integer
      if (isNaN(line)) {
        this.printer.print("Line number must be an integer.");
        return [];
      }

      //search sources for given string
      let sources = Object.values(
        this.session.view(sourcemapping.views.sources)
      );
      //we will indeed need the sources here, not just IDs
      let matchingSources = sources.filter(source =>
        source.sourcePath.includes(sourceArg)
      );

      if (matchingSources.length === 0) {
        this.printer.print(`No source file found matching ${sourceArg}.`);
        return [];
      } else if (matchingSources.length > 1) {
        //normally if there's multiple matching sources, we want to return no
        //breakpoint and print a disambiguation prompt.
        //however, if one of them has a source path that is a substring of all
        //the others...
        if (
          matchingSources.some(shortSource =>
            matchingSources.every(
              source =>
                typeof source.sourcePath !== "string" || //just ignore these I guess?
                source.sourcePath.includes(shortSource.sourcePath)
            )
          )
        ) {
          //exceptional case
          this.printer.print(
            `WARNING: Acting on all matching sources because disambiguation between them is not possible.`
          );
          return matchingSources.map(source => ({
            sourceId: source.id,
            line: line - 1 //adjust for breakpoint!
          }));
        } else {
          //normal case
          this.printer.print(
            `Multiple source files found matching ${sourceArg}.  Which did you mean?`
          );
          matchingSources.forEach(source =>
            this.printer.print(source.sourcePath)
          );
          this.printer.print("");
          return [];
        }
      }

      //otherwise, we found it!
      return [
        {
          sourceId: matchingSources[0].id,
          line: line - 1 //adjust for zero-indexing!
        }
      ];
    }

    //otherwise, it's a simple line number
    else {
      debug("absolute case");
      if (currentSourceId === null || currentSourceId === undefined) {
        this.printer.print("Cannot determine current file.");
        return [];
      }
      let line = parseInt(args[0], 10); //want an integer
      debug("line %d", line);

      if (isNaN(line)) {
        this.printer.print("Line number must be an integer.");
        return [];
      }

      return [
        {
          sourceId: currentSourceId,
          line: line - 1 //adjust for zero-indexing!
        }
      ];
    }
  }

  //note: also prints!
  async setOrClearBreakpointObject(breakpoint, setOrClear) {
    const existingBreakpoints = this.session.view(controller.breakpoints);
    //OK, we've constructed the breakpoint!  But if we're adding, we'll
    //want to adjust to make sure we don't set it on an empty line or
    //anything like that
    if (setOrClear) {
      let resolver = this.session.view(controller.breakpoints.resolver);
      breakpoint = resolver(breakpoint);
      //of course, this might result in finding that there's nowhere to
      //add it after that point
      if (breakpoint === null) {
        this.printer.print(
          "Nowhere to add breakpoint at or beyond that location."
        );
        return;
      }
    }

    const currentSource = this.session.view(controller.current.location.source);
    const currentSourceId = currentSource ? currentSource.id : null;

    //having constructed and adjusted breakpoint, here's now a
    //user-readable message describing its location
    let sources = this.session.view(sourcemapping.views.sources);
    let sourceNames = Object.assign(
      //note: only include user sources
      {},
      ...Object.entries(sources).map(([id, source]) => ({
        [id]: path.basename(source.sourcePath)
      }))
    );
    let locationMessage = DebugUtils.formatBreakpointLocation(
      breakpoint,
      true, //only relevant for node-based breakpoints
      currentSourceId,
      sourceNames
    );

    //one last check -- does this breakpoint already exist?
    let alreadyExists =
      existingBreakpoints.filter(
        existingBreakpoint =>
          existingBreakpoint.sourceId === breakpoint.sourceId &&
          existingBreakpoint.line === breakpoint.line &&
          existingBreakpoint.node === breakpoint.node //may be undefined
      ).length > 0;

    //NOTE: in the "set breakpoint" case, the above check is somewhat
    //redundant, as we're going to check again when we actually make the
    //call to add or remove the breakpoint!  But we need to check here so
    //that we can display the appropriate message.  Hopefully we can find
    //some way to avoid this redundant check in the future.

    //if it already exists and is being set, or doesn't and is being
    //cleared, report back that we can't do that
    if (setOrClear === alreadyExists) {
      if (setOrClear) {
        this.printer.print(`Breakpoint at ${locationMessage} already exists.`);
        return;
      } else {
        this.printer.print(`No breakpoint at ${locationMessage} to remove.`);
        return;
      }
    }

    //finally, if we've reached this point, do it!
    //also report back to the user on what happened
    if (setOrClear) {
      await this.session.addBreakpoint(breakpoint);
      this.printer.print(`Breakpoint added at ${locationMessage}.`);
    } else {
      await this.session.removeBreakpoint(breakpoint);
      this.printer.print(`Breakpoint removed at ${locationMessage}.`);
    }
  }

  start(terminate) {
    // if terminate is not passed, return a Promise instead
    if (terminate === undefined) {
      return util.promisify(this.start.bind(this))();
    }

    if (this.session.view(session.status.loaded)) {
      debug("loaded");
      this.printer.printSessionLoaded();
    } else if (this.session.view(session.status.isError)) {
      debug("error!");
      this.printer.printSessionError();
    } else {
      debug("didn't attempt a load");
      this.printer.printHelp();
    }

    const prompt = this.session.view(session.status.loaded)
      ? DebugUtils.formatPrompt(this.network, this.txHash)
      : DebugUtils.formatPrompt(this.network);

    this.repl = repl.start({
      prompt: prompt,
      eval: util.callbackify(this.interpreter.bind(this)),
      ignoreUndefined: true,
      done: terminate
    });
  }

  async interpreter(cmd) {
    cmd = cmd.trim();
    let cmdArgs, splitArgs;
    debug("cmd %s", cmd);

    if (cmd === ".exit") {
      cmd = "q";
    }

    //split arguments for commands that want that; split on runs of spaces
    splitArgs = cmd.trim().split(/ +/).slice(1);
    debug("splitArgs %O", splitArgs);

    //warning: this bit *alters* cmd!
    if (cmd.length > 0) {
      cmdArgs = cmd.slice(1).trim();
      cmd = cmd[0];
    }

    if (cmd === "") {
      cmd = this.lastCommand;
      cmdArgs = "";
      splitArgs = [];
    }

    //quit if that's what we were given
    if (cmd === "q") {
      process.exit();
    }

    let alreadyFinished = this.session.view(trace.finishedOrUnloaded);
    let loadFailed = false;

    // If not finished, perform commands that require state changes
    // (other than quitting or resetting)
    if (!alreadyFinished) {
      const stepSpinner = new Spinner(
        "core:debug:interpreter:step",
        "Stepping..."
      );
      switch (cmd) {
        case "o":
          await this.session.stepOver();
          break;
        case "i":
          await this.session.stepInto();
          break;
        case "u":
          await this.session.stepOut();
          break;
        case "n":
          await this.session.stepNext();
          break;
        case ";":
          //two cases -- parameterized and unparameterized
          if (cmdArgs !== "") {
            let count = parseInt(cmdArgs, 10);
            debug("cmdArgs=%s", cmdArgs);
            if (isNaN(count)) {
              this.printer.print("Number of steps must be an integer.");
              break;
            }
            await this.session.advance(count);
          } else {
            await this.session.advance();
          }
          break;
        case "c":
          await this.session.continueUntilBreakpoint();
          break;
      }
      stepSpinner.remove();
    } //otherwise, inform the user we can't do that
    else {
      switch (cmd) {
        case "o":
        case "i":
        case "u":
        case "n":
        case "c":
        case ";":
          //are we "finished" because we've reached the end, or because
          //nothing is loaded?
          if (this.session.view(session.status.loaded)) {
            this.printer.print("Transaction has halted; cannot advance.");
            this.printer.print("");
          } else {
            this.printer.print("No transaction loaded.");
            this.printer.print("");
          }
      }
    }
    if (cmd === "r") {
      //reset if given the reset command
      //(but not if nothing is loaded)
      if (this.session.view(session.status.loaded)) {
        await this.session.reset();
      } else {
        this.printer.print("No transaction loaded.");
        this.printer.print("");
      }
    }
    if (cmd === "y") {
      if (this.session.view(session.status.loaded)) {
        if (this.session.view(trace.finished)) {
          if (!this.session.view(evm.current.step.isExceptionalHalting)) {
            const errorIndex = this.session.view(
              stacktrace.current.innerErrorIndex
            );
            if (errorIndex !== null) {
              const stepSpinner = new Spinner(
                "core:debug:interpreter:step",
                "Stepping..."
              );
              await this.session.reset();
              await this.session.advance(errorIndex);
              stepSpinner.remove();
            } else {
              this.printer.print("No error to return to.");
            }
          } else {
            this.printer.print("You are already at the final error.");
            this.printer.print(
              "Use the `Y` command to return to the previous error."
            );
            this.printer.print("");
          }
        } else {
          this.printer.print(
            "This command is only usable at end of transaction; did you mean `Y`?"
          );
        }
      } else {
        this.printer.print("No transaction loaded.");
        this.printer.print("");
      }
    }
    if (cmd === "Y") {
      if (this.session.view(session.status.loaded)) {
        const errorIndex = this.session.view(
          stacktrace.current.innerErrorIndex
        );
        if (errorIndex !== null) {
          const stepSpinner = new Spinner(
            "core:debug:interpreter:step",
            "Stepping..."
          );
          await this.session.reset();
          await this.session.advance(errorIndex);
          stepSpinner.remove();
        } else {
          this.printer.print("No previous error to return to.");
        }
      } else {
        this.printer.print("No transaction loaded.");
        this.printer.print("");
      }
    }
    if (cmd === "t") {
      if (!this.fetchExternal) {
        if (!this.session.view(session.status.loaded)) {
          const txSpinner = new Spinner(
            "core:debug:interpreter:step",
            DebugUtils.formatTransactionStartMessage()
          );
          try {
            await this.session.load(cmdArgs);
            txSpinner.succeed();
            this.repl.setPrompt(DebugUtils.formatPrompt(this.network, cmdArgs));
          } catch (_) {
            txSpinner.fail();
            loadFailed = true;
          }
        } else {
          loadFailed = true;
          this.printer.print(
            "Please unload the current transaction before loading a new one."
          );
        }
      } else {
        loadFailed = true;
        this.printer.print(
          "Cannot change transactions in fetch-external mode.  Please quit and restart the debugger instead."
        );
      }
    }
    if (cmd === "T") {
      if (!this.fetchExternal) {
        if (this.session.view(session.status.loaded)) {
          await this.session.unload();
          this.printer.print("Transaction unloaded.");
          this.repl.setPrompt(DebugUtils.formatPrompt(this.network));
        } else {
          this.printer.print("No transaction to unload.");
          this.printer.print("");
        }
      } else {
        this.printer.print(
          "Cannot change transactions in fetch-external mode.  Please quit and restart the debugger instead."
        );
      }
    }
    if (cmd === "g") {
      if (!this.session.view(controller.stepIntoInternalSources)) {
        this.session.setInternalStepping(true);
        this.printer.print(
          "All debugger commands can now step into generated sources."
        );
      } else {
        this.printer.print("Generated sources already activated.");
      }
    }
    if (cmd === "G") {
      if (this.session.view(controller.stepIntoInternalSources)) {
        this.session.setInternalStepping(false);
        this.printer.print(
          "Commands other than (;) and (c) will now skip over generated sources."
        );
      } else {
        this.printer.print("Generated sources already off.");
      }
    }

    // Check if execution has (just now) stopped.
    if (this.session.view(trace.finished) && !alreadyFinished) {
      this.printer.print("");
      //check if transaction failed
      if (!this.session.view(evm.transaction.status)) {
        await this.printer.printRevertMessage();
        this.printer.print("");
        this.printer.printStacktrace(true); //final stacktrace
        this.printer.print("");
        this.printer.printErrorLocation();
      } else {
        //case if transaction succeeded
        this.printer.print("Transaction completed successfully.");
        if (
          this.session.view(sourcemapping.current.source).language !== "Vyper"
        ) {
          //HACK: not supported for vyper yet
          await this.printer.printReturnValue();
        }
      }
    }

    // Perform post printing
    // (we want to see if execution stopped before printing state).
    switch (cmd) {
      case "+":
        if (cmdArgs[0] === ":") {
          watchExpressionAnalytics(cmdArgs.substring(1));
        }
        this.enabledExpressions.add(cmdArgs);
        await this.printer.printWatchExpressionResult(cmdArgs);
        break;
      case "-":
        this.enabledExpressions.delete(cmdArgs);
        break;
      case "!":
        this.printer.printSelector(cmdArgs);
        break;
      case "?":
        this.printer.printWatchExpressions(this.enabledExpressions);
        this.printer.printBreakpoints();
        this.printer.printGeneratedSourcesState();
        break;
      case "v":
        if (
          this.session.view(sourcemapping.current.source).language === "Vyper"
        ) {
          this.printer.print(
            "Decoding of variables is not currently supported for Vyper."
          );
          break;
        }

        //first: process which sections we should print out
        const tempPrintouts = this.updatePrintouts(
          splitArgs,
          this.printer.sections,
          this.printer.sectionPrintouts
        );

        await this.printer.printVariables(tempPrintouts);
        if (this.session.view(trace.finished)) {
          await this.printer.printReturnValue();
        }
        break;
      case ":":
        watchExpressionAnalytics(cmdArgs);
        this.printer.evalAndPrintExpression(cmdArgs);
        break;
      case "b":
        await this.setOrClearBreakpoint(splitArgs, true);
        break;
      case "B":
        await this.setOrClearBreakpoint(splitArgs, false);
        break;
      case "p":
        // determine the numbers of instructions to be printed
        this.printer.instructionLines = this.parsePrintoutLines(
          splitArgs,
          this.printer.instructionLines
        );
        // process which locations we should print out
        const temporaryPrintouts = this.updatePrintouts(
          splitArgs,
          this.printer.locations,
          this.printer.locationPrintouts
        );

        if (this.session.view(session.status.loaded)) {
          if (this.session.view(trace.steps).length > 0) {
            this.printer.printInstruction(temporaryPrintouts);
            this.printer.printFile();
            this.printer.printState();
          } else {
            //if there are no trace steps, let's just print a warning message
            this.printer.print("No trace steps to inspect.");
          }
        }
        //finally, print watch expressions
        await this.printer.printWatchExpressionsResults(
          this.enabledExpressions
        );
        break;
      case "l":
        if (this.session.view(session.status.loaded)) {
          this.printer.printFile();
          // determine the numbers of lines to be printed
          this.printer.sourceLines = this.parsePrintoutLines(
            splitArgs,
            this.printer.sourceLines
          );
          this.printer.printState(
            this.printer.sourceLines.beforeLines,
            this.printer.sourceLines.afterLines
          );
        }
        break;
      case ";":
        if (!this.session.view(trace.finishedOrUnloaded)) {
          this.printer.printInstruction();
          this.printer.printFile();
          this.printer.printState();
        }
        await this.printer.printWatchExpressionsResults(
          this.enabledExpressions
        );
        break;
      case "s":
        if (this.session.view(session.status.loaded)) {
          //print final report if finished & failed, intermediate if not
          if (
            this.session.view(trace.finished) &&
            !this.session.view(evm.transaction.status)
          ) {
            this.printer.printStacktrace(true); //print final stack trace
            //Now: actually show the point where things went wrong
            this.printer.printErrorLocation(
              this.printer.sourceLines.beforeLines,
              this.printer.sourceLines.afterLines
            );
          } else {
            this.printer.printStacktrace(false); //intermediate call stack
          }
        }
        break;
      case "o":
      case "i":
      case "u":
      case "n":
      case "c":
      case "y":
      case "Y":
        if (!this.session.view(trace.finishedOrUnloaded)) {
          if (!this.session.view(sourcemapping.current.source).source) {
            this.printer.printInstruction();
          }
          this.printer.printFile();
          this.printer.printState();
        }
        await this.printer.printWatchExpressionsResults(
          this.enabledExpressions
        );
        break;
      case "r":
        if (this.session.view(session.status.loaded)) {
          this.printer.printAddressesAffected();
          this.printer.warnIfNoSteps();
          this.printer.printFile();
          this.printer.printState();
        }
        break;
      case "t":
        if (!loadFailed) {
          this.printer.printAddressesAffected();
          this.printer.warnIfNoSteps();
          this.printer.printFile();
          this.printer.printState();
        } else if (this.session.view(session.status.isError)) {
          let loadError = this.session.view(session.status.error);
          this.printer.print(loadError);
        }
        break;
      case "T":
      case "g":
      case "G":
        //nothing to print
        break;
      default:
        this.printer.printHelp(this.lastCommand);
    }

    if (
      cmd !== "b" &&
      cmd !== "B" &&
      cmd !== "v" &&
      cmd !== "h" &&
      cmd !== "p" &&
      cmd !== "l" &&
      cmd !== "?" &&
      cmd !== "!" &&
      cmd !== ":" &&
      cmd !== "+" &&
      cmd !== "r" &&
      cmd !== "-" &&
      cmd !== "t" &&
      cmd !== "T" &&
      cmd !== "g" &&
      cmd !== "G" &&
      cmd !== "s" &&
      cmd !== "y"
    ) {
      this.lastCommand = cmd;
    }
  }

  // update the printouts according to user inputs
  // called by case v for section printouts and case p for location printouts
  //
  // NOTE: THIS FUNCTION IS NOT PURE.
  //       The input printOuts is altered according to the values of other inputs: userArgs and selections.
  //       The function returns an object, tempPrintouts, that contains the selected printouts.
  updatePrintouts(userArgs, selections, printOuts) {
    let tempPrintouts = new Set();
    for (let argument of userArgs) {
      let fullSelection;
      if (argument[0] === "+" || argument[0] === "-") {
        fullSelection = argument.slice(1);
      } else {
        fullSelection = argument;
      }
      let selection = selections.find(possibleSelection =>
        fullSelection.startsWith(possibleSelection)
      );
      if (argument[0] === "+") {
        printOuts.add(selection);
      } else if (argument[0] === "-") {
        printOuts.delete(selection);
      } else {
        tempPrintouts.add(selection);
      }
    }
    for (let selection of printOuts) {
      debug("selection: %s", selection);
      tempPrintouts.add(selection);
    }
    return tempPrintouts;
  }

  // parse the numbers of lines options -<num>|+<num> from user args
  parsePrintoutLines(userArgs, currentLines) {
    let { beforeLines, afterLines } = currentLines;
    for (const argument of userArgs) {
      // ignore an option with length less than 2,such as a bare + or -
      if (argument.length < 2) continue;
      const newLines = Number(argument.slice(1));
      // ignore the arguments that are not of the correct form, number
      if (isNaN(newLines)) continue;
      if (argument[0] === "-") {
        beforeLines = newLines;
      } else if (argument[0] === "+") {
        afterLines = newLines;
      }
    }
    return { beforeLines, afterLines };
  }
}

module.exports = {
  DebugInterpreter
};


/***/ }),

/***/ 429099:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debugModule = __webpack_require__(615158);
const debug = debugModule("lib:debug:printer");

const path = __webpack_require__(371017);
const util = __webpack_require__(473837);

const DebugUtils = __webpack_require__(93293);
const Codec = __webpack_require__(20102);
const colors = __webpack_require__(183196);
const Interpreter = __webpack_require__(797941);

const selectors = (__webpack_require__(692851).selectors);
const { session, sourcemapping, trace, controller, data, evm, stacktrace } =
  selectors;

class DebugPrinter {
  constructor(config, session) {
    this.config = config;
    this.session = session;
    this.select = expr => {
      let selector, result;

      try {
        selector = expr
          .split(".")
          .reduce((sel, next) => (next.length ? sel[next] : sel), selectors);
      } catch (_) {
        throw new Error("Unknown selector: %s", expr);
      }

      // throws its own exception
      // note: we avoid using this.session so that this
      // can be called from js-interpreter
      result = session.view(selector);

      return result;
    };

    const colorizeSourceObject = source => {
      const { source: raw, language } = source;
      const detabbed = DebugUtils.tabsToSpaces(raw);
      return DebugUtils.colorize(detabbed, language);
    };

    this.colorizedSources = Object.assign(
      {},
      ...Object.entries(this.session.view(sourcemapping.views.sources)).map(
        ([id, source]) => ({
          [id]: colorizeSourceObject(source)
        })
      )
    );

    // location printouts for command (p): print instruction and state
    //   sto: Storage
    //   cal: Calldata
    //   mem: Memory
    //   sta: Stack
    // Note that this is a public variable and can be modified from outside.
    this.locationPrintouts = new Set(["sta"]);
    this.locations = ["sto", "cal", "mem", "sta"]; //should remain constant

    // section printouts for command (v): print variables and values
    //   bui: Solidity built-ins
    //   glo: Global constants
    //   con: Contract variables
    //   loc: Local variables
    // Note that this is a public variable and can be modified from outside.
    this.sectionPrintouts = new Set(["bui", "glo", "con", "loc"]);
    this.sections = ["bui", "glo", "con", "loc"]; //should remain constant

    // numbers of instructions before and after the current instruction to be printed
    // used by commands (p) and (;)
    // Note that this is a public variable and can be modified from outside.
    this.instructionLines = { beforeLines: 3, afterLines: 3 };

    // numbers of lines before and after the current line to be printed
    // used by commands (l) and (s)
    // Note that this is a public variable and can be modified from outside.
    this.sourceLines = { beforeLines: 5, afterLines: 3 };
  }

  print(...args) {
    this.config.logger.log(...args);
  }

  printSessionLoaded() {
    this.printAddressesAffected();
    this.warnIfNoSteps();
    this.printHelp();
    debug("Help printed");
    this.printFile();
    debug("File printed");
    this.printState();
    debug("State printed");
  }

  printSessionError() {
    this.print(this.session.view(session.status.error));
    this.printHelp();
  }

  printAddressesAffected() {
    const affectedInstances = this.session.view(session.info.affectedInstances);

    this.config.logger.log("");
    this.config.logger.log("Addresses affected:");
    this.config.logger.log(
      DebugUtils.formatAffectedInstances(affectedInstances)
    );
  }

  warnIfNoSteps() {
    if (this.session.view(trace.steps).length === 0) {
      this.config.logger.log(
        `${colors.bold(
          "Warning:"
        )} this transaction has no trace steps. This may happen if you are attempting to debug a transaction sent to an externally-owned account, or if the node you are connecting to failed to produce a trace for some reason. Please check your configuration and try again.`
      );
    }
  }

  printHelp(lastCommand) {
    this.config.logger.log("");
    this.config.logger.log(DebugUtils.formatHelp(lastCommand));
  }

  printFile(location = this.session.view(controller.current.location)) {
    let message = "";

    const sourcePath = location.source.sourcePath;

    if (sourcePath) {
      message += path.basename(sourcePath);
    } else {
      message += "?";
    }

    this.config.logger.log("");
    this.config.logger.log(message + ":");
  }

  printState(
    contextBefore = 2,
    contextAfter = 0,
    location = this.session.view(controller.current.location)
  ) {
    const {
      source: { id: sourceId },
      sourceRange: range
    } = location;

    if (sourceId === undefined) {
      this.config.logger.log();
      this.config.logger.log("1: // No source code found.");
      this.config.logger.log("");
      return;
    }

    //we don't just get extract the source text from the location because passed-in location may be
    //missing the source text
    const source = this.session.view(sourcemapping.views.sources)[sourceId]
      .source;
    const colorizedSource = this.colorizedSources[sourceId];

    debug("range: %o", range);

    // We were splitting on OS.EOL, but it turns out on Windows,
    // in some environments (perhaps?) line breaks are still denoted by just \n
    const splitLines = str => str.split(/\r?\n/g);

    const lines = splitLines(source);
    const colorizedLines = splitLines(colorizedSource);

    this.config.logger.log("");
    // We create printoutRange with range.lines as initial value for printing.
    let printoutRange = range.lines;

    // We print a warning message and display the end of source code when the
    // instruction's byte-offset to the start of the range in the source code
    // is past the end of source code.
    if (range.start >= source.length) {
      this.config.logger.log(
        `${colors.bold(
          "Warning:"
        )} Location is past end of source, displaying end.`
      );
      this.config.logger.log("");
      // We set the printoutRange with the end of source code.
      // Note that "lines" is the split lines of source code as defined above.
      printoutRange = {
        start: {
          line: lines.length - 1,
          column: 0
        },
        end: {
          line: lines.length - 1,
          column: 0
        }
      };
    }

    //HACK -- the line-pointer formatter doesn't work right with colorized
    //lines, so we pass in the uncolored version too
    this.config.logger.log(
      DebugUtils.formatRangeLines(
        colorizedLines,
        printoutRange,
        lines,
        contextBefore,
        contextAfter
      )
    );

    this.config.logger.log("");
  }

  printInstruction(locations = this.locationPrintouts) {
    const instruction = this.session.view(sourcemapping.current.instruction);
    const instructions = this.session.view(sourcemapping.current.instructions);
    const step = this.session.view(trace.step);
    const traceIndex = this.session.view(trace.index);
    const totalSteps = this.session.view(trace.steps).length;
    //note calldata will be a Uint8Array, not a hex string or array of such
    const calldata = this.session.view(data.current.state.calldata);
    //storage here is an object mapping hex words to hex words, all w/o 0x prefix
    const storage = this.session.view(evm.current.codex.storage);

    this.config.logger.log("");
    if (locations.has("sto")) {
      this.config.logger.log(DebugUtils.formatStorage(storage));
      this.config.logger.log("");
    }
    if (locations.has("cal")) {
      this.config.logger.log(DebugUtils.formatCalldata(calldata));
      this.config.logger.log("");
    }
    if (locations.has("mem")) {
      this.config.logger.log(DebugUtils.formatMemory(step.memory));
      this.config.logger.log("");
    }
    if (locations.has("sta")) {
      this.config.logger.log(DebugUtils.formatStack(step.stack));
      this.config.logger.log("");
    }

    this.config.logger.log("Instructions:");
    if (!instruction || instruction.pc === undefined) {
      // printout warning message if the debugger does not have the code for this contract
      this.config.logger.log(
        `${colors.bold(
          "Warning:"
        )} The debugger does not have the code for this contract.`
      );
    } else {
      // printout instructions
      const previousInstructions = this.instructionLines.beforeLines;
      const upcomingInstructions = this.instructionLines.afterLines;
      const currentIndex = instruction.index;

      // add an ellipse if there exist additional instructions before
      if (currentIndex - previousInstructions > 0) {
        this.config.logger.log("...");
      }
      // printout 3 previous instructions
      for (
        let i = Math.max(currentIndex - previousInstructions, 0);
        i < currentIndex;
        i++
      ) {
        this.config.logger.log(DebugUtils.formatInstruction(instructions[i]));
      }

      // printout current instruction
      this.config.logger.log(DebugUtils.formatCurrentInstruction(instruction));

      // printout 3 upcoming instructions
      for (
        let i = currentIndex + 1;
        i <=
        Math.min(currentIndex + upcomingInstructions, instructions.length - 1);
        i++
      ) {
        this.config.logger.log(DebugUtils.formatInstruction(instructions[i]));
      }

      // add an ellipse if there exist additional instructions after
      if (currentIndex + upcomingInstructions < instructions.length - 1) {
        this.config.logger.log("...");
      }
    }

    this.config.logger.log("");
    this.config.logger.log(
      "Step " + (traceIndex + 1).toString() + "/" + totalSteps.toString()
    );
    this.config.logger.log(step.gas + " gas remaining");
  }

  /**
   * @param {string} selector
   */
  printSelector(selector) {
    const result = this.select(selector);
    const debugSelector = debugModule(selector);
    debugSelector.enabled = true;
    debugSelector("%O", result);
  }

  printWatchExpressions(expressions) {
    if (expressions.size === 0) {
      this.config.logger.log("No watch expressions added.");
      return;
    }

    this.config.logger.log("");
    for (const expression of expressions) {
      this.config.logger.log("  " + expression);
    }
  }

  printBreakpoints() {
    const sources = this.session.view(sourcemapping.views.sources);
    const sourceNames = Object.assign(
      //note: only include user sources
      {},
      ...Object.entries(sources).map(([id, source]) => ({
        [id]: path.basename(source.sourcePath)
      }))
    );
    const breakpoints = this.session.view(controller.breakpoints);
    if (breakpoints.length > 0) {
      for (let breakpoint of this.session.view(controller.breakpoints)) {
        let currentLocation = this.session.view(controller.current.location);
        let locationMessage = DebugUtils.formatBreakpointLocation(
          breakpoint,
          currentLocation.node !== undefined &&
            breakpoint.sourceId === currentLocation.source.sourceId &&
            breakpoint.node === currentLocation.astRef,
          currentLocation.source.id,
          sourceNames
        );
        this.config.logger.log("  Breakpoint at " + locationMessage);
      }
    } else {
      this.config.logger.log("No breakpoints added.");
    }
  }

  printGeneratedSourcesState() {
    if (this.session.view(controller.stepIntoInternalSources)) {
      this.config.logger.log("Generated sources are turned on.");
    } else {
      this.config.logger.log("Generated sources are turned off.");
    }
  }

  //this doesn't really *need* to be async as we could use codec directly, but, eh
  async printRevertMessage() {
    this.config.logger.log(
      DebugUtils.truffleColors.red("Transaction halted with a RUNTIME ERROR.")
    );
    this.config.logger.log("");
    const revertDecodings = await this.session.returnValue(); //in this context we know it's a revert
    debug("revertDecodings: %o", revertDecodings);
    switch (revertDecodings.length) {
      case 0:
        this.config.logger.log(
          "There was revert data, but it could not be decoded."
        );
        break;
      case 1:
        const revertDecoding = revertDecodings[0];
        switch (revertDecoding.kind) {
          case "failure":
            this.config.logger.log(
              "There was no revert message.  This may be due to an intentional halting expression, such as assert(), revert(), or require(), or could be due to an unintentional exception such as out-of-gas exceptions."
            );
            break;
          case "revert":
            const signature = Codec.AbiData.Utils.abiSignature(
              revertDecoding.abi
            );
            switch (signature) {
              case "Error(string)":
                const revertStringInfo =
                  revertDecoding.arguments[0].value.value;
                let revertString;
                switch (revertStringInfo.kind) {
                  case "valid":
                    revertString = revertStringInfo.asString;
                    this.config.logger.log(`Revert message: ${revertString}`);
                    break;
                  case "malformed":
                    //turn into a JS string while smoothing over invalid UTF-8
                    //slice 2 to remove 0x prefix
                    revertString = Buffer.from(
                      revertStringInfo.asHex.slice(2),
                      "hex"
                    ).toString();
                    this.config.logger.log(`Revert message: ${revertString}`);
                    this.config.logger.log(
                      `${colors.bold(
                        "Warning:"
                      )} This message contained invalid UTF-8.`
                    );
                    break;
                }
                break;
              case "Panic(uint)":
                const panicCode = revertDecoding.arguments[0].value.value.asBN;
                const panicString = DebugUtils.panicString(panicCode, true); //get verbose panic string :)
                this.config.logger.log(
                  `Panic: Code 0x${panicCode.toString(
                    16
                  )}. This code indicates that ${panicString.toLowerCase()}`
                );
                break;
              default:
                this.config.logger.log("The following error was thrown:");
                this.config.logger.log(
                  DebugUtils.formatCustomError(revertDecoding, 2)
                );
            }
            break;
        }
        break;
      default:
        this.config.logger.log(
          "There was revert data, but it could not be unambiguously decoded."
        );
        this.config.logger.log("Possible interpretations:");
        for (const decoding of revertDecodings) {
          this.config.logger.log(DebugUtils.formatCustomError(decoding, 2));
        }
        break;
    }
    this.config.logger.log(
      "Please inspect your transaction parameters and contract code to determine the meaning of this error."
    );
  }

  async printReturnValue() {
    //note: when printing revert messages, this will do so in a somewhat
    //different way than printRevertMessage does
    const inspectOptions = {
      colors: true,
      depth: null,
      maxArrayLength: null,
      breakLength: 30
    }; //copypaste warning: copied from debug-utils!
    const allocationFound = Boolean(
      this.session.view(data.current.returnAllocation)
    );
    const decodings = await this.session.returnValue();
    debug("decodings: %o", decodings);
    if (!allocationFound && decodings.length === 0) {
      //case 1: no allocation found, decoding failed
      this.config.logger.log("");
      this.config.logger.log(
        "A value was returned but it could not be decoded."
      );
      this.config.logger.log("");
    } else if (!allocationFound && decodings[0].status === true) {
      //case 2: no allocation found, decoding succeeded, but not a revert
      //(i.e. it's a presumed selfdestruct; no value was returned)
      //do nothing
    } else if (allocationFound && decodings.length === 0) {
      //case 3: allocation found but decoding failed
      this.config.logger.log("");
      this.config.logger.log("The return value could not be decoded.");
      this.config.logger.log("");
    } else if (allocationFound && decodings[0].kind === "selfdestruct") {
      //case 4: allocation found, apparent self-destruct (note due to the use of [0] this
      //won't occur if no return value was expected, as return takes priority over selfdestruct)
      //Oops -- in an actual selfdestruct, we won't have the code! >_>
      //(Not until reconstruct mode exists...) Oh well, leaving this in
      this.config.logger.log("");
      this.config.logger.log(
        "No value was returned even though one was expected.  This may indicate a self-destruct."
      );
      this.config.logger.log("");
    } else if (decodings[0].kind === "failure") {
      //case 5: revert (no message)
      this.config.logger.log("");
      this.config.logger.log("There was no revert message.");
      this.config.logger.log("");
    } else if (decodings[0].kind === "unknownbytecode") {
      //case 6: unknown bytecode
      this.config.logger.log("");
      this.config.logger.log(
        "Bytecode was returned, but it could not be identified."
      );
      this.config.logger.log("");
    } else if (
      decodings[0].kind === "return" &&
      decodings[0].arguments.length === 0
    ) {
      //case 7: return values but with no content
      //do nothing
    } else if (decodings[0].kind === "bytecode") {
      //case 8: known bytecode
      this.config.logger.log("");
      //we just defer to the ReturndataDecodingInspector in this case
      this.config.logger.log(
        util.inspect(
          new Codec.Export.ReturndataDecodingInspector(decodings[0]),
          inspectOptions
        )
      );
      this.config.logger.log("");
    } else if (
      decodings[0].kind === "revert" &&
      decodings.filter(decoding => decoding.kind === "revert").length === 1
    ) {
      //case 9: revert (with message) (unambiguous)
      const decoding = decodings[0];
      const signature = Codec.AbiData.Utils.abiSignature(decoding.abi);
      this.config.logger.log("");
      switch (signature) {
        case "Error(string)": {
          //case 9a: revert string
          //(special handling, don't use inspector)
          const prefix = "Revert string: ";
          const value = decodings[0].arguments[0].value;
          const formatted = DebugUtils.formatValue(value, prefix.length);
          this.config.logger.log(prefix + formatted);
          break;
        }
        case "Panic(uint)": {
          //case 9b: panic code
          //(special handling, don't use inspector)
          const prefix = "Panic code: ";
          const value = decodings[0].arguments[0].value;
          const formatted = DebugUtils.formatValue(value, prefix.length);
          const meaning = DebugUtils.panicString(value.value.asBN);
          this.config.logger.log(`${prefix} ${formatted} (${meaning})`);
          break;
        }
        default:
          //case 9c: custom error
          //just use the inspector
          this.config.logger.log(
            util.inspect(
              new Codec.Export.ReturndataDecodingInspector(decodings[0]),
              inspectOptions
            )
          );
      }
      this.config.logger.log("");
    } else if (
      decodings[0].kind === "revert" &&
      decodings.filter(decoding => decoding.kind === "revert").length > 1
    ) {
      //case 10: ambiguous revert with message
      this.config.logger.log(
        "Ambiguous error thrown, possible interpretations:"
      );
      for (const decoding of decodings) {
        if (decoding.kind !== "revert") {
          break;
        }
        //again, we can use the inspector
        this.config.logger.log(
          util.inspect(
            new Codec.Export.ReturndataDecodingInspector(decodings[0]),
            inspectOptions
          )
        );
      }
    } else if (
      decodings[0].kind === "return" &&
      decodings[0].arguments.length > 0
    ) {
      //case 11: actual return values to print!
      //we're not going to use the inspector here, we're going to
      //handle this in a custom manner
      this.config.logger.log("");
      const values = decodings[0].arguments;
      if (values.length === 1 && !values[0].name) {
        //case 11a: if there's only one value and it's unnamed
        const value = values[0].value;
        const prefix = "Returned value: ";
        const formatted = DebugUtils.formatValue(value, prefix.length);
        this.config.logger.log(prefix + formatted);
      } else {
        //case 11b: otherwise
        this.config.logger.log("Returned values:");
        const prefixes = values.map(({ name }, index) =>
          name ? `${name}: ` : `Component #${index + 1}: `
        );
        const maxLength = Math.max(...prefixes.map(prefix => prefix.length));
        const paddedPrefixes = prefixes.map(prefix =>
          prefix.padStart(maxLength)
        );
        for (let index = 0; index < values.length; index++) {
          const { value } = values[index];
          const prefix = paddedPrefixes[index];
          const formatted = DebugUtils.formatValue(value, maxLength);
          this.config.logger.log(prefix + formatted);
        }
      }
      this.config.logger.log("");
    } else if (decodings[0].kind === "returnmessage") {
      //case 12: raw binary data
      //(special handling, don't use inspector)
      this.config.logger.log("");
      const fallbackOutputDefinition = this.session.view(
        data.current.fallbackOutputForContext
      );
      const name = (fallbackOutputDefinition || {}).name;
      const prettyData = `${colors.green("hex")}${DebugUtils.formatValue(
        decodings[0].data.slice(2), //remove '0x'
        0,
        true
      )}`;
      if (name) {
        //case 12a: it has a name
        this.config.logger.log("Returned values:");
        this.config.logger.log(`${name}: ${prettyData}`);
      } else {
        //case 12b: it doesn't
        this.config.logger.log(`Returned value: ${prettyData}`);
      }
      //it's already a string, so we'll pass the nativized parameter
      //and hack this together :)
      //also, since we only have one thing and it's a string, we'll skip
      //fancy indent processing
      this.config.logger.log("");
    }
  }

  printStacktrace(final) {
    this.config.logger.log(final ? "Stacktrace:" : "Call stack:");
    let report = final
      ? this.session.view(stacktrace.current.finalReport)
      : this.session.view(stacktrace.current.report);
    this.config.logger.log(DebugUtils.formatStacktrace(report));
  }

  printErrorLocation(linesBefore, linesAfter) {
    const stacktraceReport = this.session.view(stacktrace.current.finalReport);
    const lastUserFrame = stacktraceReport
      .slice()
      .reverse() //clone before reversing, reverse is in-place!
      .find(frame => !frame.location.internal);
    if (lastUserFrame) {
      this.config.logger.log("");
      this.config.logger.log(
        DebugUtils.truffleColors.red("Location of error:")
      );
      this.printFile(lastUserFrame.location);
      this.printState(linesBefore, linesAfter, lastUserFrame.location);
    }
  }

  async printWatchExpressionsResults(expressions) {
    debug("expressions %o", expressions);
    for (let expression of expressions) {
      this.config.logger.log(expression);
      // Add some padding. Note: This won't work with all loggers,
      // meaning it's not portable. But doing this now so we can get something
      // pretty until we can build more architecture around this.
      // Note: Selector results already have padding, so this isn't needed.
      if (expression[0] === ":") {
        process.stdout.write("  ");
      }
      await this.printWatchExpressionResult(expression);
    }
  }

  async printWatchExpressionResult(expression) {
    const type = expression[0];
    const exprArgs = expression.substring(1);

    if (type === "!") {
      this.printSelector(exprArgs);
    } else {
      await this.evalAndPrintExpression(exprArgs, 2, true);
    }
  }

  async printVariables(sectionOuts = this.sectionPrintouts) {
    const values = await this.session.variables({ indicateUnknown: true });
    const sections = this.session.view(data.current.identifiers.sections);

    const sectionNames = {
      builtin: "Solidity built-ins",
      global: "Global constants",
      contract: "Contract variables",
      local: "Local variables"
    };

    this.config.logger.log();

    let printLegend = false;

    // printout the sections that are included in the inputs and have positive contents length
    for (const [section, variables] of Object.entries(sections)) {
      // only check the first 3 characters of each name given in the input sectionPrintouts
      // since each section name defined in the constructor contains 3 characters
      const printThisSection = sectionOuts.has(section.slice(0, 3));
      if (printThisSection && variables.length > 0) {
        this.config.logger.log(sectionNames[section] + ":");
        // Get the length of the longest name.
        const longestNameLength = variables.reduce((longest, name) => {
          return name.length > longest ? name.length : longest;
        }, -Infinity);
        for (const variable of variables) {
          const paddedName = variable.padStart(longestNameLength) + ":";
          const value = values[variable];
          const formatted = DebugUtils.formatValue(
            value,
            longestNameLength + 5
          );
          this.config.logger.log("  " + paddedName, formatted);
          if (Codec.Export.containsDeliberateReadError(value)) {
            printLegend = true;
          }
        }
        this.config.logger.log();
      }
    }

    if (printLegend) {
      this.config.logger.log(
        "Note: Some storage variables could not be fully decoded; the debugger can only see storage it has seen touched during the transaction."
      );
    }
  }

  /**
   * @param {string} raw - user input for watch expression
   *
   * performs pre-processing on `raw`, using !<...> delimeters to refer
   * to selector expressions.
   *
   * e.g., to see a particular part of the current trace step's stack:
   *
   *    debug(development:0x4228cdd1...)>
   *
   *        :!<trace.step.stack>[1]
   */
  async evalAndPrintExpression(raw, indent, suppress) {
    let variables = await this.session.variables({ indicateUnknown: true });

    //if we're just dealing with a single variable, handle that case
    //separately (so that we can do things in a better way for that
    //case)
    let variable = raw.trim();
    if (variable in variables) {
      let formatted = DebugUtils.formatValue(variables[variable], indent);
      this.config.logger.log(formatted);
      this.config.logger.log();
      if (Codec.Export.containsDeliberateReadError(variables[variable])) {
        this.config.logger.log(
          "Note: Variable could not be fully decoded as the debugger can only see storage it has seen touched during the transaction."
        );
      }
      return;
    }
    debug("expression case");

    // converts all !<...> expressions to JS-valid selector requests
    const preprocessSelectors = expr => {
      const regex = /!<([^>]+)>/g;
      const select = "$"; // expect repl context to have this func
      const replacer = (_, selector) => `${select}("${selector}")`;

      return expr.replace(regex, replacer);
    };

    //HACK
    //if we're not in the single-variable case, we'll need to do some
    //things to Javascriptify our variables so that the JS syntax for
    //using them is closer to the Solidity syntax
    let context = Codec.Format.Utils.Inspect.unsafeNativizeVariables(variables);

    //HACK -- we can't use "this" as a variable name, so we're going to
    //find an available replacement name, and then modify the context
    //and expression appropriately
    let pseudoThis = "_this";
    while (pseudoThis in context) {
      pseudoThis = "_" + pseudoThis;
    }
    //in addition to pseudoThis, which replaces this, we also have
    //pseudoPseudoThis, which replaces pseudoThis in order to ensure
    //that any uses of pseudoThis yield an error instead of showing this
    let pseudoPseudoThis = "thereisnovariableofthatname";
    while (pseudoPseudoThis in context) {
      pseudoPseudoThis = "_" + pseudoPseudoThis;
    }
    context = DebugUtils.cleanThis(context, pseudoThis);
    let expr = raw.replace(
      //those characters in [] are the legal JS variable name characters
      //note that pseudoThis contains no special characters
      new RegExp("(?<![a-zA-Z0-9_$])" + pseudoThis + "(?![a-zA-Z0-9_$])"),
      pseudoPseudoThis
    );
    expr = expr.replace(
      //those characters in [] are the legal JS variable name characters
      /(?<![a-zA-Z0-9_$])this(?![a-zA-Z0-9_$])/,
      pseudoThis
    );
    //note that pseudoThis contains no dollar signs to screw things up

    expr = preprocessSelectors(expr);

    try {
      const result = this.safelyEvaluateWithSelectors(expr, context);
      const formatted = DebugUtils.formatValue(result, indent, true);
      this.config.logger.log(formatted);
      this.config.logger.log();
    } catch (e) {
      if (!suppress) {
        this.config.logger.log(e);
      } else {
        this.config.logger.log(DebugUtils.formatValue(undefined, indent, true));
      }
    }
  }

  //evaluates expression with the variables in context,
  //but also has `$` as a variable that is the select function
  safelyEvaluateWithSelectors(expression, context) {
    const select = this.select;
    let interpreter;
    interpreter = new Interpreter(expression, function (
      interpreter,
      globalObject
    ) {
      //first let's set up our select function (which will be called $)
      interpreter.setProperty(
        globalObject,
        "$",
        interpreter.createNativeFunction(selectorName => {
          debug("selecting %s", selectorName);
          return interpreter.nativeToPseudo(select(selectorName));
        })
      );
      //now let's set up the variables
      for (const [variable, value] of Object.entries(context)) {
        try {
          debug("variable: %s", variable);
          //note: circular objects wll raise an exception here and get excluded.
          interpreter.setProperty(
            globalObject,
            variable,
            interpreter.nativeToPseudo(value)
          );
        } catch (_) {
          debug("failure");
          //just omit things that don't work
        }
      }
    });
    interpreter.run();
    return interpreter.pseudoToNative(interpreter.value);
  }
}

module.exports = {
  DebugPrinter
};


/***/ }),

/***/ 687440:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile:debug");
const Codec = __importStar(__webpack_require__(20102));
class DebugRecognizer {
    constructor(bugger) {
        this.addressesToSkip = new Set();
        this.badFetchAddresses = [];
        this.badCompileAddresses = [];
        this.badFetchers = [];
        this.bugger = bugger; //no clone, note!
    }
    getErrors() {
        return {
            fetch: this.badFetchAddresses,
            compile: this.badCompileAddresses,
            fetchers: this.badFetchers
        };
    }
    //helper method
    getUnrecognizedAddresses() {
        debug("getting unknown addresses");
        const instances = this.bugger.view(this.bugger.selectors.session.info.affectedInstances);
        debug("got instances");
        return Object.entries(instances)
            .filter(([_, { contractName }]) => contractName === undefined)
            .map(([address, _]) => address);
    }
    /*
     * Interface methods follow
     */
    isAddressUnrecognized(address) {
        return this.getUnrecognizedAddresses().includes(address);
    }
    getAnUnrecognizedAddress() {
        return this.getUnrecognizedAddresses().find(address => !this.addressesToSkip.has(address));
    }
    markUnrecognizable(address, reason) {
        //debugger does not keep track of detailed errors
        if (reason) {
            switch (reason) {
                case "fetch":
                    this.badFetchAddresses.push(address);
                    break;
                case "compile":
                    this.badCompileAddresses.push(address);
                    break;
                default:
                    //just ignore ones with unsupported language
                    break;
            }
        }
        this.addressesToSkip.add(address);
    }
    markBadFetcher(fetcherName) {
        this.badFetchers.push(fetcherName);
    }
    addCompiledInfo(info, address) {
        return __awaiter(this, void 0, void 0, function* () {
            debug("compileResult: %O", info.compileResult);
            const compilations = info.compileResult.compilations;
            const shimmedCompilations = Codec.Compilations.Utils.shimCompilations(compilations, `externalFor(${address})Via(${info.fetchedVia})`);
            yield this.bugger.addExternalCompilations(shimmedCompilations);
        });
    }
}
exports.DebugRecognizer = DebugRecognizer;
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ 350588:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSortedFetcherConstructors = exports.fetchAndCompileForRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile:fetch");
const semver_1 = __importDefault(__webpack_require__(517110));
const source_fetcher_1 = __importDefault(__webpack_require__(887031));
const source_fetcher_2 = __webpack_require__(887031);
const config_1 = __importDefault(__webpack_require__(120553));
const { Compile } = __webpack_require__(4273); //sorry for untyped import!
const utils_1 = __webpack_require__(373727);
function fetchAndCompileForRecognizer(recognizer, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = utils_1.normalizeFetchAndCompileOptions(options);
        const fetcherConstructors = getSortedFetcherConstructors(utils_1.normalizeFetcherNames(normalizedOptions));
        const fetchers = yield getFetchers(fetcherConstructors, normalizedOptions, recognizer);
        //now: the main loop!
        let address;
        while ((address = recognizer.getAnUnrecognizedAddress()) !== undefined) {
            yield tryFetchAndCompileAddress(address, fetchers, recognizer, normalizedOptions);
        }
    });
}
exports.fetchAndCompileForRecognizer = fetchAndCompileForRecognizer;
//sort/filter fetchers by user's order, if given; otherwise use default order
function getSortedFetcherConstructors(userFetcherNames) {
    let sortedFetchers = [];
    if (userFetcherNames) {
        for (let name of userFetcherNames) {
            let Fetcher = source_fetcher_1.default.find(Fetcher => Fetcher.fetcherName === name);
            if (Fetcher) {
                sortedFetchers.push(Fetcher);
            }
            else {
                throw new Error(`Unknown external source service ${name}.`);
            }
        }
    }
    else {
        sortedFetchers = source_fetcher_1.default;
    }
    return sortedFetchers;
}
exports.getSortedFetcherConstructors = getSortedFetcherConstructors;
function getFetchers(fetcherConstructors, options, recognizer) {
    return __awaiter(this, void 0, void 0, function* () {
        const networkId = options.network.networkId;
        //make fetcher instances. we'll filter out ones that don't support this
        //network (and note ones that yielded errors)
        return (yield Promise.all(fetcherConstructors.map((Fetcher) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield Fetcher.forNetworkId(networkId, ((options.fetch || {}).fetcherOptions || {})[Fetcher.fetcherName]);
            }
            catch (error) {
                if (!(error instanceof source_fetcher_2.InvalidNetworkError)) {
                    //if it's *not* just an invalid network, log the error.
                    recognizer.markBadFetcher(Fetcher.fetcherName);
                }
                //either way, filter this fetcher out
                return null;
            }
        })))).filter((fetcher) => fetcher !== null);
    });
}
function tryFetchAndCompileAddress(address, fetchers, recognizer, fetchAndCompileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        let found = false;
        let failureReason; //undefined if no failure
        let failureError;
        //(this includes if no source is found)
        for (const fetcher of fetchers) {
            //now comes all the hard parts!
            //get our sources
            let result;
            try {
                debug("getting sources for %s via %s", address, fetcher.fetcherName);
                result = yield fetcher.fetchSourcesForAddress(address);
            }
            catch (error) {
                debug("error in getting sources! %o", error);
                failureReason = "fetch";
                failureError = error;
                continue;
            }
            if (result === null) {
                debug("no sources found");
                //null means they don't have that address
                continue;
            }
            //if we do have it, extract sources & options
            debug("got sources!");
            const { sources, options } = result; //not same options as above, sorry for name confusion
            if (options.language === "Vyper") {
                //if it's not Solidity, bail out now
                debug("found Vyper, bailing out!");
                recognizer.markUnrecognizable(address, "language");
                //break out of the fetcher loop, since *no* fetcher will work here
                break;
            }
            //set up the config
            let externalConfig = config_1.default.default().with({
                compilers: {
                    solc: options
                }
            });
            //if using docker, transform it (this does nothing if not using docker)
            externalConfig = transformIfUsingDocker(externalConfig, fetchAndCompileOptions);
            //compile the sources
            let compileResult;
            try {
                compileResult = yield Compile.sources({
                    options: externalConfig.with({ quiet: true }),
                    sources
                });
            }
            catch (error) {
                debug("compile error: %O", error);
                failureReason = "compile";
                failureError = error;
                continue; //try again with a different fetcher, I guess?
            }
            //add it!
            yield recognizer.addCompiledInfo({
                compileResult,
                sourceInfo: result,
                fetchedVia: fetcher.fetcherName
            }, address);
            failureReason = undefined; //mark as *not* failed in case a previous fetcher failed
            failureError = undefined;
            //check: did this actually help?
            debug("checking result");
            if (!recognizer.isAddressUnrecognized(address)) {
                debug("address %s successfully recognized via %s", address, fetcher.fetcherName);
                found = true;
                //break out of the fetcher loop -- we got what we want
                break;
            }
            debug("address %s still unrecognized", address);
        }
        if (found === false) {
            //if we couldn't find it, add it to the list of addresses to skip
            recognizer.markUnrecognizable(address, failureReason, failureError);
        }
    });
}
function transformIfUsingDocker(externalConfig, fetchAndCompileOptions) {
    const useDocker = Boolean((fetchAndCompileOptions.compile || {}).docker);
    if (!useDocker) {
        //if they're not using docker, no need to transform anything :)
        return externalConfig;
    }
    const givenVersion = externalConfig.compilers.solc.version;
    //if they are, we have to ask: are they using a nightly?
    if (semver_1.default.prerelease(givenVersion)) {
        //we're not going to attempt to make Docker work with nightlies.
        //just keep Docker turned off.
        return externalConfig;
    }
    //otherwise, turn on Docker, and reduce the version to its simple form.
    const simpleVersion = semver_1.default.valid(givenVersion);
    if (simpleVersion === null) {
        //this should never happen
        throw new Error("Fetched source has unparseable compiler version");
    }
    return externalConfig.merge({
        compilers: {
            solc: {
                version: simpleVersion,
                docker: true
            }
        }
    });
}
//# sourceMappingURL=fetch.js.map

/***/ }),

/***/ 705523:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSupportedNetworks = exports.fetchAndCompileForDebugger = exports.fetchAndCompileMultiple = exports.fetchAndCompile = exports.fetchAndCompileForRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile");
const recognizer_1 = __webpack_require__(436846);
const multiple_1 = __webpack_require__(700943);
const debug_2 = __webpack_require__(687440);
const fetch_1 = __webpack_require__(350588);
Object.defineProperty(exports, "fetchAndCompileForRecognizer", ({ enumerable: true, get: function () { return fetch_1.fetchAndCompileForRecognizer; } }));
const utils_1 = __webpack_require__(373727);
function fetchAndCompile(address, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = utils_1.normalizeFetchAndCompileOptions(options);
        const recognizer = new recognizer_1.SingleRecognizer(address);
        yield fetch_1.fetchAndCompileForRecognizer(recognizer, normalizedOptions);
        return recognizer.getResult();
    });
}
exports.fetchAndCompile = fetchAndCompile;
/**
 * warning: while this function deduplicates inputs,
 * it does *not* make any further effort to avoid redundant
 * fetches (e.g. if multiple addresses share the same source),
 * unlike fetchAndCompileForDebugger
 */
function fetchAndCompileMultiple(addresses, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = utils_1.normalizeFetchAndCompileOptions(options);
        const recognizer = new multiple_1.MultipleRecognizer(addresses);
        yield fetch_1.fetchAndCompileForRecognizer(recognizer, normalizedOptions);
        return recognizer.getResults();
    });
}
exports.fetchAndCompileMultiple = fetchAndCompileMultiple;
//note: this function is called primarily for its side-effects
//(i.e. adding compilations to the debugger), NOT its return value!
function fetchAndCompileForDebugger(bugger, //sorry; this should be a debugger object
options) {
    return __awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = utils_1.normalizeFetchAndCompileOptions(options);
        const recognizer = new debug_2.DebugRecognizer(bugger);
        yield fetch_1.fetchAndCompileForRecognizer(recognizer, normalizedOptions);
        return recognizer.getErrors();
    });
}
exports.fetchAndCompileForDebugger = fetchAndCompileForDebugger;
function getSupportedNetworks(optionsOrFetcherNames) {
    const fetcherNames = utils_1.normalizeFetcherNames(optionsOrFetcherNames);
    const fetchers = fetch_1.getSortedFetcherConstructors(fetcherNames);
    //strictly speaking these are fetcher constructors, but since we
    //won't be using fetcher instances in this function, I'm not going
    //to worry about the difference
    let supportedNetworks = {};
    for (const fetcher of fetchers) {
        const fetcherNetworks = fetcher.getSupportedNetworks();
        for (const name in fetcherNetworks) {
            if (name in supportedNetworks) {
                supportedNetworks[name].fetchers.push(fetcher.fetcherName);
            }
            else {
                supportedNetworks[name] = Object.assign(Object.assign({}, fetcherNetworks[name]), { fetchers: [fetcher.fetcherName] });
            }
        }
    }
    return supportedNetworks;
}
exports.getSupportedNetworks = getSupportedNetworks;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 700943:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultipleRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile:multiple");
const web3_utils_1 = __importDefault(__webpack_require__(118269));
class MultipleRecognizer {
    constructor(addresses) {
        this.addressesToSkip = new Set();
        this.results = {};
        this.failureLog = {};
        this.unrecognizedAddresses = [
            ...new Set(addresses.map(web3_utils_1.default.toChecksumAddress))
        ]; //remove duplicates (checksum to make case-insensitive & canonical) and clone
    }
    getResults() {
        return {
            results: this.results,
            failures: this.failureLog
        };
    }
    /*
     * Interface methods follow
     */
    isAddressUnrecognized(address) {
        return this.unrecognizedAddresses.includes(address);
    }
    getAnUnrecognizedAddress() {
        return this.unrecognizedAddresses.find(address => !this.addressesToSkip.has(address));
    }
    markUnrecognizable(address, reason, error) {
        this.failureLog[address] = { reason, error };
        this.addressesToSkip.add(address);
    }
    markBadFetcher(_fetcherName) {
        //do nothing
    }
    addCompiledInfo(info, address) {
        this.results[address] = info;
        const index = this.unrecognizedAddresses.indexOf(address);
        this.unrecognizedAddresses.splice(index, 1); //delete the address from the array
    }
}
exports.MultipleRecognizer = MultipleRecognizer;
//# sourceMappingURL=multiple.js.map

/***/ }),

/***/ 436846:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SingleRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile:recognizer");
class SingleRecognizer {
    constructor(address) {
        this.recognized = false;
        this.address = address;
    }
    getResult() {
        return {
            compileResult: this.compileResult,
            sourceInfo: this.sourceInfo,
            fetchedVia: this.fetchedVia
        };
    }
    /*
     * Interface methods follow
     */
    isAddressUnrecognized(address) {
        return !this.recognized || address !== this.address; //I guess?
    }
    getAnUnrecognizedAddress() {
        return this.recognized ? undefined : this.address;
    }
    markUnrecognizable(address, reason, error) {
        //just throw...
        if (error) {
            throw error;
        }
        else if (reason) {
            switch (reason) {
                case "fetch":
                    throw new Error(`Error in fetching sources for ${address}`);
                case "compile":
                    throw new Error(`Error in compiling sources for ${address}`);
                case "language":
                    throw new Error(`Sources for ${address} were not in a supported language`);
            }
        }
        else {
            throw new Error(`No verified sources found for ${address}`);
        }
    }
    markBadFetcher(_fetcherName) {
        //do nothing
    }
    addCompiledInfo(info, address) {
        this.compileResult = info.compileResult;
        this.sourceInfo = info.sourceInfo;
        if (address === this.address) {
            //I guess? this should never be false
            this.recognized = true;
            this.fetchedVia = info.fetchedVia;
        }
    }
}
exports.SingleRecognizer = SingleRecognizer;
//# sourceMappingURL=recognizer.js.map

/***/ }),

/***/ 373727:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeFetcherNames = exports.normalizeFetchAndCompileOptions = void 0;
const config_1 = __importDefault(__webpack_require__(120553));
const source_fetcher_1 = __importDefault(__webpack_require__(887031));
function normalizeFetchAndCompileOptions(options) {
    if (options instanceof config_1.default) {
        let normalizedOptions = {
            network: {
                networkId: options.network_id
            },
            compile: {
                docker: ((options.compilers || {}).solc || {}).docker
            },
            fetch: {
                precedence: options.sourceFetchers,
                fetcherOptions: {}
            }
        };
        for (const fetcher of source_fetcher_1.default) {
            const fetcherName = fetcher.fetcherName;
            const fetcherOptions = options[fetcherName];
            //@ts-ignore TS can't recognize that the objects we just set up are definitely not undefined :-/
            normalizedOptions.fetch.fetcherOptions[fetcherName] = fetcherOptions;
        }
        return normalizedOptions;
    }
    else {
        return options;
    }
}
exports.normalizeFetchAndCompileOptions = normalizeFetchAndCompileOptions;
function normalizeFetcherNames(optionsOrFetcherNames) {
    if (Array.isArray(optionsOrFetcherNames)) {
        return optionsOrFetcherNames;
    }
    else if (!optionsOrFetcherNames) {
        return optionsOrFetcherNames;
    }
    else {
        const options = normalizeFetchAndCompileOptions(optionsOrFetcherNames);
        return ((options || {}).fetch || {}).precedence;
    }
}
exports.normalizeFetcherNames = normalizeFetcherNames;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 571103:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidNetworkError = exports.removeLibraries = exports.makeTimer = exports.makeFilename = void 0;
//these imports aren't actually necessary, but why not :)
const util_1 = __importDefault(__webpack_require__(473837));
const timers_1 = __webpack_require__(939512);
function makeFilename(name, extension = ".sol") {
    if (!name) {
        return "Contract" + extension;
    }
    if (name.endsWith(extension)) {
        return name;
    }
    else {
        return name + extension;
    }
}
exports.makeFilename = makeFilename;
exports.makeTimer = util_1.default.promisify(timers_1.setTimeout);
function removeLibraries(settings, alsoRemoveCompilationTarget = false) {
    let copySettings = Object.assign({}, settings);
    delete copySettings.libraries;
    if (alsoRemoveCompilationTarget) {
        delete copySettings.compilationTarget;
    }
    return copySettings;
}
exports.removeLibraries = removeLibraries;
class InvalidNetworkError extends Error {
    constructor(networkId, fetcherName) {
        super(`Invalid network ID ${networkId} for fetcher ${fetcherName}`);
        this.networkId = networkId;
        this.fetcherName = fetcherName;
        this.name = "InvalidNetworkError";
    }
}
exports.InvalidNetworkError = InvalidNetworkError;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ 574578:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("source-fetcher:etherscan");
// untyped import since no @types/web3-utils exists
const Web3Utils = __webpack_require__(118269);
const common_1 = __webpack_require__(571103);
const networks_1 = __webpack_require__(200367);
const axios_1 = __importDefault(__webpack_require__(409669));
const async_retry_1 = __importDefault(__webpack_require__(972047));
const etherscanCommentHeader = `/**
 *Submitted for verification at Etherscan.io on 20XX-XX-XX
*/

`; //note we include that final newline
//this looks awkward but the TS docs actually suggest this :P
const EtherscanFetcher = (_a = class EtherscanFetcher {
        constructor(networkId, apiKey = "") {
            const networkName = networks_1.networkNamesById[networkId];
            if (networkName === undefined ||
                !(networkName in EtherscanFetcher.apiDomainsByNetworkName)) {
                throw new common_1.InvalidNetworkError(networkId, "etherscan");
            }
            this.networkName = networkName;
            debug("apiKey: %s", apiKey);
            this.apiKey = apiKey;
            const baseDelay = this.apiKey ? 200 : 3000; //etherscan permits 5 requests/sec w/a key, 1/3sec w/o
            const safetyFactor = 1; //no safety factor atm
            this.delay = baseDelay * safetyFactor;
            this.ready = common_1.makeTimer(0); //at start, it's ready to go immediately
        }
        static get fetcherName() {
            return "etherscan";
        }
        get fetcherName() {
            return EtherscanFetcher.fetcherName;
        }
        static forNetworkId(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                debug("options: %O", options);
                debug("id:", id);
                return new EtherscanFetcher(id, options ? options.apiKey : "");
            });
        }
        static getSupportedNetworks() {
            return Object.fromEntries(Object.entries(networks_1.networksByName).filter(([name, _]) => name in EtherscanFetcher.apiDomainsByNetworkName));
        }
        fetchSourcesForAddress(address) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.getSuccessfulResponse(address);
                return EtherscanFetcher.processResult(response.result[0]);
            });
        }
        getSuccessfulResponse(address) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialTimeoutFactor = 1.5; //I guess?
                return yield async_retry_1.default(() => __awaiter(this, void 0, void 0, function* () { return yield this.makeRequest(address); }), {
                    retries: 3,
                    minTimeout: this.delay * initialTimeoutFactor
                });
            });
        }
        determineUrl() {
            const domain = EtherscanFetcher.apiDomainsByNetworkName[this.networkName];
            return `https://${domain}/api`;
        }
        makeRequest(address) {
            return __awaiter(this, void 0, void 0, function* () {
                //not putting a try/catch around this; if it throws, we throw
                yield this.ready;
                const responsePromise = axios_1.default.get(this.determineUrl(), {
                    params: {
                        module: "contract",
                        action: "getsourcecode",
                        address,
                        apikey: this.apiKey
                    },
                    responseType: "json",
                    maxRedirects: 50
                });
                this.ready = common_1.makeTimer(this.delay);
                const response = (yield responsePromise).data;
                if (response.status === "0") {
                    throw new Error(response.result);
                }
                return response;
            });
        }
        static processResult(result) {
            //we have 5 cases here.
            //case 1: the address doesn't exist
            if (result.SourceCode === "" &&
                result.ABI === "Contract source code not verified") {
                return null;
            }
            //case 2: it's a Vyper contract
            if (result.CompilerVersion.startsWith("vyper:")) {
                return this.processVyperResult(result);
            }
            let multifileJson;
            try {
                //try to parse the source JSON.  if it succeeds,
                //we're in the multi-file case.
                multifileJson = JSON.parse(result.SourceCode);
            }
            catch (_) {
                //otherwise, we could be single-file or we could be full JSON.
                //for full JSON input, etherscan will stick an extra pair of braces around it
                if (result.SourceCode.startsWith("{") &&
                    result.SourceCode.endsWith("}")) {
                    const trimmedSource = result.SourceCode.slice(1).slice(0, -1); //remove braces
                    let fullJson;
                    try {
                        fullJson = JSON.parse(trimmedSource);
                    }
                    catch (_) {
                        //if it still doesn't parse, it's single-source I guess?
                        //(note: we shouldn't really end up here?)
                        debug("single-file input??");
                        return this.processSingleResult(result);
                    }
                    //case 5: full JSON input
                    debug("json input");
                    return this.processJsonResult(result, fullJson);
                }
                //case 3 (the way it should happen): single source
                debug("single-file input");
                return this.processSingleResult(result);
            }
            //case 4: multiple sources
            debug("multi-file input");
            return this.processMultiResult(result, multifileJson);
        }
        static processSingleResult(result) {
            const filename = common_1.makeFilename(result.ContractName);
            return {
                contractName: result.ContractName,
                sources: {
                    //we prepend this header comment so that line numbers in the debugger
                    //will match up with what's displayed on the website; note that other
                    //cases don't display a similar header on the website
                    [filename]: etherscanCommentHeader + result.SourceCode
                },
                options: {
                    language: "Solidity",
                    version: result.CompilerVersion,
                    settings: this.extractSettings(result),
                    specializations: {
                        libraries: this.processLibraries(result.Library),
                        constructorArguments: result.ConstructorArguments
                    }
                }
            };
        }
        static processMultiResult(result, sources) {
            return {
                contractName: result.ContractName,
                sources: this.processSources(sources),
                options: {
                    language: "Solidity",
                    version: result.CompilerVersion,
                    settings: this.extractSettings(result),
                    specializations: {
                        libraries: this.processLibraries(result.Library),
                        constructorArguments: result.ConstructorArguments
                    }
                }
            };
        }
        static processJsonResult(result, jsonInput) {
            return {
                contractName: result.ContractName,
                sources: this.processSources(jsonInput.sources),
                options: {
                    language: jsonInput.language,
                    version: result.CompilerVersion,
                    settings: common_1.removeLibraries(jsonInput.settings),
                    specializations: {
                        libraries: jsonInput.settings.libraries,
                        constructorArguments: result.ConstructorArguments
                    }
                }
            };
        }
        static processVyperResult(result) {
            const filename = common_1.makeFilename(result.ContractName, ".vy");
            //note: this means filename will always be Vyper_contract.vy
            return {
                sources: {
                    [filename]: result.SourceCode
                },
                options: {
                    language: "Vyper",
                    version: result.CompilerVersion.replace(/^vyper:/, ""),
                    settings: this.extractVyperSettings(result),
                    specializations: {
                        constructorArguments: result.ConstructorArguments
                    }
                }
            };
        }
        static processSources(sources) {
            return Object.assign({}, ...Object.entries(sources).map(([path, { content: source }]) => ({
                [common_1.makeFilename(path)]: source
            })));
        }
        static extractSettings(result) {
            const evmVersion = result.EVMVersion === "Default" ? undefined : result.EVMVersion;
            const optimizer = {
                enabled: result.OptimizationUsed === "1",
                runs: parseInt(result.Runs)
            };
            //old version got libraries here, but we don't actually want that!
            if (evmVersion !== undefined) {
                return {
                    optimizer,
                    evmVersion
                };
            }
            else {
                return {
                    optimizer
                };
            }
        }
        static processLibraries(librariesString) {
            let libraries;
            if (librariesString === "") {
                libraries = {};
            }
            else {
                libraries = Object.assign({}, ...librariesString.split(";").map(pair => {
                    const [name, address] = pair.split(":");
                    return { [name]: Web3Utils.toChecksumAddress(address) };
                }));
            }
            return { "": libraries }; //empty string as key means it applies to all contracts
        }
        static extractVyperSettings(result) {
            const evmVersion = result.EVMVersion === "Default" ? undefined : result.EVMVersion;
            //the optimize flag is not currently supported by etherscan;
            //any Vyper contract currently verified on etherscan necessarily has
            //optimize flag left unspecified (and therefore effectively true).
            //do NOT look at OptimizationUsed for Vyper contracts; it will always
            //be "0" even though in fact optimization *was* used.  just leave
            //the optimize flag unspecified.
            if (evmVersion !== undefined) {
                return { evmVersion };
            }
            else {
                return {};
            }
        }
    },
    //then, afterwards, start a new timer.
    _a.apiDomainsByNetworkName = {
        mainnet: "api.etherscan.io",
        ropsten: "api-ropsten.etherscan.io",
        kovan: "api-kovan.etherscan.io",
        rinkeby: "api-rinkeby.etherscan.io",
        goerli: "api-goerli.etherscan.io",
        sepolia: "api-sepolia.etherscan.io",
        optimistic: "api-optimistic.etherscan.io",
        "kovan-optimistic": "api-kovan-optimistic.etherscan.io",
        arbitrum: "api.arbiscan.io",
        "rinkeby-arbitrum": "api-testnet.arbiscan.io",
        polygon: "api.polygonscan.com",
        "mumbai-polygon": "api-mumbai.polygonscan.com",
        binance: "api.bscscan.com",
        "testnet-binance": "api-testnet.bscscan.com",
        fantom: "api.ftmscan.com",
        "testnet-fantom": "api-testnet.ftmscan.com",
        avalanche: "api.snowtrace.io",
        "fuji-avalanche": "api-testnet.snowtrace.io",
        heco: "api.hecoinfo.com",
        "testnet-heco": "api-testnet.hecoinfo.com",
        moonbeam: "api-moonbeam.moonscan.io",
        moonriver: "api-moonriver.moonscan.io",
        "moonbase-alpha": "api-moonbase.moonscan.io",
        cronos: "api.cronoscan.com",
        "testnet-cronos": "api-testnet.cronoscan.com",
        bttc: "api.bttcscan.com",
        "donau-bttc": "api-testnet.bttcscan.com",
        aurora: "api.aurorascan.dev",
        "testnet-aurora": "api-testnet.aurorascan.dev",
        celo: "api.celoscan.xyz",
        "alfajores-celo": "api-alfajores.celoscan.xyz",
        clover: "api.clvscan.com"
    },
    _a);
exports["default"] = EtherscanFetcher;
//# sourceMappingURL=etherscan.js.map

/***/ }),

/***/ 887031:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidNetworkError = void 0;
const common_1 = __webpack_require__(571103);
Object.defineProperty(exports, "InvalidNetworkError", ({ enumerable: true, get: function () { return common_1.InvalidNetworkError; } }));
const etherscan_1 = __importDefault(__webpack_require__(574578));
const sourcify_1 = __importDefault(__webpack_require__(711284));
const Fetchers = [etherscan_1.default, sourcify_1.default];
exports["default"] = Fetchers;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 200367:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.networksByName = exports.networkNamesById = void 0;
exports.networkNamesById = {
    1: "mainnet",
    3: "ropsten",
    4: "rinkeby",
    5: "goerli",
    42: "kovan",
    11155111: "sepolia",
    10: "optimistic",
    69: "kovan-optimistic",
    42161: "arbitrum",
    421611: "rinkeby-arbitrum",
    137: "polygon",
    80001: "mumbai-polygon",
    100: "xdai",
    99: "poa",
    77: "sokol-poa",
    56: "binance",
    97: "testnet-binance",
    42220: "celo",
    44787: "alfajores-celo",
    62320: "baklava-celo",
    43114: "avalanche",
    43113: "fuji-avalanche",
    11111: "wagmi-avalanche",
    53935: "dfk-avalanche",
    432201: "dexalot-avalanche",
    335: "testnet-dfk-avalance",
    40: "telos",
    41: "testnet-telos",
    8: "ubiq",
    311752642: "oneledger",
    4216137055: "frankenstein-oneledger",
    57: "syscoin",
    5700: "tanenbaum-syscoin",
    288: "boba",
    28: "rinkeby-boba",
    106: "velas",
    82: "meter",
    83: "testnet-meter",
    1313161554: "aurora",
    1313161555: "testnet-aurora",
    250: "fantom",
    4002: "testnet-fantom",
    128: "heco",
    256: "testnet-heco",
    1284: "moonbeam",
    1285: "moonriver",
    1287: "moonbase-alpha",
    122: "fuse",
    11297108109: "palm",
    11297108099: "testnet-palm",
    70: "hoo",
    25: "cronos",
    338: "testnet-cronos",
    199: "bttc",
    1029: "donau-bttc",
    1024: "clover",
    44: "crab-darwinia",
    43: "pangolin-darwinia",
    9001: "evmos",
    9000: "testnet-evmos",
    62621: "multivac",
    534: "candle",
    192837465: "gather",
    486217935: "devnet-gather",
    356256156: "testnet-gather",
    246: "energyweb",
    73799: "volta-energyweb",
    71402: "godwoken",
    71401: "testnet-godwoken"
    //I'm not including crystaleum as it has network ID different from chain ID
};
exports.networksByName = Object.fromEntries(Object.entries(exports.networkNamesById).map(([id, name]) => [name, { name, networkId: Number(id), chainId: Number(id) }] //id is a string since it's a key so must use Number()
));
//# sourceMappingURL=networks.js.map

/***/ }),

/***/ 711284:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("source-fetcher:sourcify");
const common_1 = __webpack_require__(571103);
const networks_1 = __webpack_require__(200367);
const axios_1 = __importDefault(__webpack_require__(409669));
const async_retry_1 = __importDefault(__webpack_require__(972047));
//this looks awkward but the TS docs actually suggest this :P
const SourcifyFetcher = (_a = class SourcifyFetcher {
        constructor(networkId) {
            //but may be in the future
            this.domain = "repo.sourcify.dev";
            this.networkId = networkId;
            this.networkName = networks_1.networkNamesById[networkId];
            if (this.networkName === undefined ||
                !SourcifyFetcher.supportedNetworks.has(this.networkName)) {
                throw new common_1.InvalidNetworkError(networkId, "sourcify");
            }
        }
        static get fetcherName() {
            return "sourcify";
        }
        get fetcherName() {
            return SourcifyFetcher.fetcherName;
        }
        static forNetworkId(id, _options) {
            return __awaiter(this, void 0, void 0, function* () {
                //in the future, we may add protocol and node options,
                //but these don't exist yet
                return new SourcifyFetcher(id);
            });
        }
        static getSupportedNetworks() {
            return Object.fromEntries(Object.entries(networks_1.networksByName).filter(([name, _]) => SourcifyFetcher.supportedNetworks.has(name)));
        }
        fetchSourcesForAddress(address) {
            return __awaiter(this, void 0, void 0, function* () {
                let result = yield this.fetchSourcesForAddressAndMatchType(address, "full");
                if (!result) {
                    //if we got nothing when trying a full match, try for a partial match
                    result = yield this.fetchSourcesForAddressAndMatchType(address, "partial");
                }
                //if partial match also fails, just return null
                return result;
            });
        }
        fetchSourcesForAddressAndMatchType(address, matchType) {
            return __awaiter(this, void 0, void 0, function* () {
                const metadata = yield this.getMetadata(address, matchType);
                debug("metadata: %O", metadata);
                if (!metadata) {
                    debug("no metadata");
                    return null;
                }
                let sources;
                sources = Object.assign({}, ...(yield Promise.all(Object.entries(metadata.sources).map(([sourcePath, { content: source }]) => __awaiter(this, void 0, void 0, function* () {
                    return ({
                        [sourcePath]: source !== undefined
                            ? source //sourcify doesn't support this yet but they're planning it
                            : yield this.getSource(address, sourcePath, matchType)
                    });
                })))));
                const constructorArguments = yield this.getConstructorArgs(address, matchType);
                debug("compilationTarget: %O", metadata.settings.compilationTarget);
                return {
                    contractName: Object.values(metadata.settings.compilationTarget)[0],
                    sources,
                    options: {
                        language: metadata.language,
                        version: metadata.compiler.version,
                        //we also pass the flag to remove compilationTarget, as its
                        //presence can cause compile errors
                        settings: common_1.removeLibraries(metadata.settings, true),
                        specializations: {
                            constructorArguments,
                            libraries: metadata.settings.libraries
                        }
                    }
                };
            });
        }
        getMetadata(address, matchType) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.requestWithRetries({
                        url: `https://${this.domain}/contracts/${matchType}_match/${this.networkId}/${address}/metadata.json`,
                        method: "get",
                        responseType: "json",
                        maxRedirects: 50
                    });
                }
                catch (error) {
                    //is this a 404 error? if so just return null
                    debug("error: %O", error);
                    if (error.response && error.response.status === 404) {
                        return null;
                    }
                    //otherwise, we've got a problem; rethrow the error
                    throw error;
                }
            });
        }
        getSource(address, sourcePath, matchType) {
            return __awaiter(this, void 0, void 0, function* () {
                //note: sourcify replaces special characters in paths with underscores
                //(special characters here being anything other than ASCII alphanumerics,
                //hyphens, periods, and forward slashes)
                const transformedSourcePath = sourcePath.replace(/[^\w.\/-]/gu, "_");
                return yield this.requestWithRetries({
                    url: `https://${this.domain}/contracts/${matchType}_match/${this.networkId}/${address}/sources/${transformedSourcePath}`,
                    responseType: "text",
                    method: "get",
                    maxRedirects: 50
                });
            });
        }
        getConstructorArgs(address, matchType) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const constructorArgs = yield this.requestWithRetries({
                        url: `https://${this.domain}/contracts/${matchType}_match/${this.networkId}/${address}/constructor-args.txt`,
                        method: "get",
                        responseType: "text",
                        maxRedirects: 50
                    });
                    return constructorArgs.slice(2); //remove initial "0x"
                }
                catch (error) {
                    //is this a 404 error? if so just return undefined
                    debug("error: %O", error);
                    if (error.response && error.response.status === 404) {
                        return undefined;
                    }
                    //otherwise, we've got a problem; rethrow the error
                    throw error;
                }
            });
        }
        requestWithRetries(requestObject //sorry, trying to import the type properly ran into problems
        ) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield async_retry_1.default((bail) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        //note: we use axios.request rather than just axios so we can stub it in tests!
                        return (yield axios_1.default.request(requestObject)).data;
                    }
                    catch (error) {
                        //check: is this a 404 error? if so give up
                        if (error.response && error.response.status === 404) {
                            bail(error); //don't retry
                        }
                        else {
                            throw error; //retry
                        }
                    }
                }), { retries: 3 } //leaving minTimeout as default 1000
                );
            });
        }
    },
    _a.supportedNetworks = new Set([
        "mainnet",
        "ropsten",
        "kovan",
        "rinkeby",
        "goerli",
        "kovan",
        "sepolia",
        "optimistic",
        "kovan-optimistic",
        "arbitrum",
        "rinkeby-arbitrum",
        "polygon",
        "mumbai-polygon",
        "xdai",
        //sourcify does *not* support poa core...?
        "sokol-poa",
        "binance",
        "testnet-binance",
        "celo",
        "alfajores-celo",
        "baklava-celo",
        "avalanche",
        "fuji-avalanche",
        "wagmi-avalanche",
        "dfk-avalanche",
        "testnet-dfk-avalanche",
        "dexalot-avalanche",
        "telos",
        "testnet-telos",
        "ubiq",
        "oneledger",
        "frankenstein-oneledger",
        "syscoin",
        "tanenbaum-syscoin",
        "boba",
        "rinkeby-boba",
        "velas",
        "meter",
        "testnet-meter",
        "aurora",
        "testnet-aurora",
        "fuse",
        "moonbeam",
        "moonriver",
        "moonbase-alpha",
        "palm",
        "testnet-palm",
        "crab-darwinia",
        "pangolin-darwinia",
        "evmos",
        "testnet-evmos",
        "multivac",
        "candle",
        "gather",
        "devnet-gather",
        "testnet-gather",
        "energyweb",
        "volta-energyweb",
        //sourcify does *not* support godwoken mainnet...?
        "testnet-godwoken"
        //I'm excluding crystaleum as it has network ID different from chain ID
    ]),
    _a);
exports["default"] = SourcifyFetcher;
//# sourceMappingURL=sourcify.js.map

/***/ })

};
;
//# sourceMappingURL=458.bundled.js.map