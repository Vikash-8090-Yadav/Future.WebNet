#!/usr/bin/env node

exports.id = 7941;
exports.ids = [7941];
exports.modules = {

/***/ 622219:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 622219;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 115021:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 115021;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 507745:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 507745;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 645982:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 645982;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 118967:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 118967;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 641912:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 641912;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 160627:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fse = __webpack_require__(655674);
const del = __webpack_require__(935163);
const WorkflowCompile = __webpack_require__(577135);
const BuildError = __webpack_require__(142863);
const {spawn} = __webpack_require__(532081);
const spawnargs = __webpack_require__(372255);
const _ = __webpack_require__(440409);
const expect = __webpack_require__(414096);

function CommandBuilder(command) {
  this.command = command;
}

CommandBuilder.prototype.build = function (options, callback) {
  console.log("Running `" + this.command + "`...");

  const args = spawnargs(this.command);
  const ps = args.shift();

  const cmd = spawn(ps, args, {
    detached: false,
    cwd: options.working_directory,
    env: _.merge(process.env, {
      WORKING_DIRECTORY: options.working_directory,
      BUILD_DESTINATION_DIRECTORY: options.destination_directory,
      BUILD_CONTRACTS_DIRECTORY: options.contracts_build_directory
    })
  });

  cmd.stdout.on("data", function (data) {
    console.log(data.toString());
  });

  cmd.stderr.on("data", function (data) {
    console.error(data);
  });

  cmd.on("close", function (code) {
    let error = null;
    if (code !== 0) {
      error = "Command exited with code " + code;
    }
    callback(error);
  });
};

const Build = {
  clean: async function (options) {
    const destination = options.build_directory;
    const contracts_build_directory = options.contracts_build_directory;

    // Clean first.
    await del([destination + "/*", "!" + contracts_build_directory]);
    fse.ensureDirSync(destination);
  },

  build: async function (options) {
    expect.options(options, [
      "build_directory",
      "working_directory",
      "contracts_build_directory",
      "networks"
    ]);

    const logger = options.logger || console;
    let builder = options.build;

    // Duplicate build directory for legacy purposes
    options.destination_directory = options.build_directory;

    if (builder === null || typeof builder === "undefined") {
      logger.log(
        "No build configuration found. Preparing to compile contracts."
      );
    } else if (typeof builder === "string") {
      builder = new CommandBuilder(builder);
    } else if (typeof builder === "function") {
      // If they've only provided a build function, use that.
      builder = { build: builder };
    } else if (builder.build == null) {
      throw new BuildError(
        "Build configuration can no longer be specified as an object. Please see our documentation for an updated list of supported build configurations."
      );
    }

    // Use our own clean method unless the builder supplies one.
    let clean = this.clean;
    if (builder && builder.hasOwnProperty("clean")) {
      clean = builder.clean;
    }

    await clean(options);

    // If necessary. This prevents errors due to the .sol.js files not existing.
    await WorkflowCompile.compileAndSave(options);
    if (builder) {
      builder.build(options, function (err) {
        if (typeof err === "string") {
          throw new BuildError(err);
        }
      });
    }
  }
};

module.exports = Build;


/***/ }),

/***/ 523525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(158327),
  meta: __webpack_require__(462571)
};


/***/ }),

/***/ 158327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const OS = __webpack_require__(822037);
  const colors = __webpack_require__(183196);
  const deprecationMessage = colors.yellow(
    `> The build command is planned ` +
      `for deprecation in version 6 of Truffle.${OS.EOL}> See ` +
      `https://github.com/trufflesuite/truffle/issues/3226 for more ` +
      `information.`
  );
  console.log(deprecationMessage);
  const Config = __webpack_require__(120553);
  const Build = __webpack_require__(160627);
  const config = Config.detect(options);

  return await Build.build(config);
};


/***/ }),

/***/ 914033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(938666),
  meta: __webpack_require__(553051)
};


/***/ }),

/***/ 938666:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(371017);
const fse = __webpack_require__(655674);

module.exports = async function (options) {
  const TruffleError = __webpack_require__(673321);
  const WorkflowCompile = __webpack_require__(577135);
  const Config = __webpack_require__(120553);
  const config = Config.detect(options);

  if (config.list !== undefined) {
    return await listVersions(config);
  }

  if (
    options.saveIntermediate === true ||
    (typeof options.saveIntermediate === "string" &&
      options.saveIntermediate.trim() === "")
  ) {
    // user asked to save the intermediate compilation results
    // but didn't provide the file to save the results to
    throw new TruffleError(
      "You must provide a file to save compilation results to."
    );
  }

  if (config._ && config._.length > 0) {
    // set paths based on command-line inputs, transforming to absolute
    // paths where appropriate
    config.paths = config._.map(specifiedPath => {
      // convert relative paths to absolute paths based on whether
      // the naive absolute path exists on disk
      //
      // NOTE in case of collision where the specified path refers to some
      // non-FS source (e.g. `truffle/Assert.sol`) and where that specified
      // path corresponds to an existing file relative to the working dir.,
      // this selects the latter as priority over the former.

      const absolutePath = path.resolve(
        config.working_directory,
        specifiedPath
      );

      // i.e., pass the absolutePath if it's a real file, otherwise just
      // pass whatever was specified.
      if (fse.existsSync(absolutePath)) {
        return absolutePath;
      } else {
        return specifiedPath;
      }
    });
  }

  const compilationOutput = await WorkflowCompile.compile(config);
  if (options.saveIntermediate) {
    // Get the filename the user provided to save the compilation results to
    const compilationOutputFile = path.resolve(options.saveIntermediate);

    await fse.writeFile(
      compilationOutputFile,
      JSON.stringify(compilationOutput),
      { encoding: "utf8" }
    );
  }

  const result = await WorkflowCompile.save(config, compilationOutput);
  if (config.db && config.db.enabled) {
    await WorkflowCompile.assignNames(config, result);
  }
};

const listVersions = async function (options) {
  const { CompilerSupplier } = __webpack_require__(4273);
  const { asyncTake } = __webpack_require__(484248);

  const supplier = new CompilerSupplier({
    solcConfig: {
      ...options.compilers.solc,
      // HACK to force use of the VersionRange or Docker strategy
      // as implemented, Docker requires a version to be specified, and so
      // we can't simply remove this field entirely.
      version: "0.5.16",
      docker: options.list === "docker"
    },
    events: options.events
  });

  const log = options.logger.log;
  options.list = options.list.length ? options.list : "releases";

  const { latestRelease, releases, prereleases } = await supplier.list();
  if (options.list === "latestRelease") {
    log(JSON.stringify(latestRelease, null, " "));
    return;
  }

  const allVersions = options.list === "prereleases" ? prereleases : releases;
  const versions = options.all ? allVersions : asyncTake(10, allVersions);

  if (options.all && options.list === "docker") {
    log(
      "Warning: using `--all` with `--list=docker` is very slow and makes " +
        "many HTTP requests."
    );
    log(
      "You may instead want to browse tags on the web here: " +
        "https://hub.docker.com/r/ethereum/solc/tags/"
    );
  }

  const tags = [];
  // use `for await` because Docker strategy returns AsyncIterableIterators
  for await (const version of versions) {
    tags.push(version);
  }

  // Docker tags are best browsed via their own web UI
  if (options.list === "docker" && !options.all) {
    tags.push("See more at: hub.docker.com/r/ethereum/solc/tags/");
  }

  log(JSON.stringify(tags, null, " "));
  return;
};


/***/ }),

/***/ 674445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(783523),
  meta: __webpack_require__(624722)
};


/***/ }),

/***/ 783523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const userLevelSettings = ["analytics"];
/**
 * run config commands to get/set/list Truffle config options
 * @param {Object} options
 **/
module.exports = async function (options) {
  const googleAnalytics = __webpack_require__(902860);
  const Config = __webpack_require__(120553);
  const OS = __webpack_require__(822037);

  let command;
  if (options.enableAnalytics || options.disableAnalytics) {
    // TODO: Deprecate the --(en|dis)able-analytics flag in favor of `set analytics true`
    command = {
      set: true,
      userLevel: true,
      key: "analytics",
      value: options.enableAnalytics || false
    };
    const message =
      `> WARNING: The --enable-analytics and ` +
      `--disable-analytics flags have been deprecated.${OS.EOL}> Please ` +
      `use 'truffle config set analytics <boolean>'.`;
    console.warn(OS.EOL + message + OS.EOL);
  } else {
    command = parse(options._);
  }

  if (command === null) {
    return await googleAnalytics.setUserConfigViaPrompt();
  } else if (command.userLevel) {
    switch (command.key) {
      case "analytics": {
        if (command.set) {
          googleAnalytics.setAnalytics(command.value);
        } else {
          options.logger.log(googleAnalytics.getAnalytics());
        }
        break;
      }
    }

    return;
  } else if (command.list) {
    options.logger.log("Truffle config values");
    options.logger.log(`analytics = ${googleAnalytics.getAnalytics()}`);
  } else {
    const config = Config.detect(options);

    if (command.set) {
      options.logger.log(
        "Setting project-level parameters is not supported yet."
      );
      // TODO: add support for writing project-level settings to the truffle config file
      // config[command.key] = command.value;
    } else {
      options.logger.log(config[command.key]);
    }
    return;
  }
};

const parse = function (args) {
  if (args.length === 0) {
    return null;
  }

  let option = args[0];

  if (typeof option !== "string") {
    // invalid option
    throw new Error(`Invalid config option "${option}"`);
  }
  option = option.toLowerCase();

  let set = false;
  let list = false;
  let key = args[1];
  let value = args[2];

  switch (option) {
    case "get": {
      set = false;
      if (typeof key === "undefined" || key === null || key === "") {
        // invalid key
        throw new Error("Must provide a <key>");
      }

      break;
    }
    case "set": {
      set = true;
      if (typeof key === "undefined" || key === null || key === "") {
        // invalid key
        throw new Error("Must provide a <key>");
      }

      if (typeof value !== "string" || value === "") {
        // invalid value
        throw new Error("Must provide a <value-for-set>");
      }

      switch (value.toLowerCase()) {
        case "null": {
          value = null;
          break;
        }
        case "undefined": {
          value = undefined;
          break;
        }
        case "true": {
          value = true;
          break;
        }
        case "false": {
          value = false;
          break;
        }
        default: {
          // check if number, otherwise leave as string
          const float = parseFloat(value);
          if (!isNaN(float) && value === float.toString()) {
            value = float;
          }
          break;
        }
      }

      break;
    }
    case "list": {
      list = true;
      break;
    }
    default: {
      if (
        option !== "--enable-analytics" &&
        option !== "--disable-analytics" &&
        option !== ""
      ) {
        // TODO: Deprecate the --(en|dis)able-analytics flag in favor for `enable analytics`
        // invalid command!
        throw new Error(`Invalid config option "${option}"`);
      } else {
        // we should not have gotten here
        return null;
      }
    }
  }

  return {
    set,
    list,
    userLevel: userLevelSettings.includes(key),
    key,
    value
  };
};


/***/ }),

/***/ 789923:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(369909),
  meta: __webpack_require__(721288)
};


/***/ }),

/***/ 369909:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { Console, excludedCommands } = __webpack_require__(968303);
  const { Environment } = __webpack_require__(376765);
  const commands = __webpack_require__(291874);
  const loadConfig = __webpack_require__(932);

  if (options.url && options.network) {
    throw new Error("'url' and 'network' are mutually exclusive options");
  }

  let config = loadConfig(options);

  const consoleCommands = commands.reduce((acc, name) => {
    return !excludedCommands.has(name)
      ? Object.assign(acc, { [name]: commands[name] })
      : acc;
  }, {});

  await Environment.detect(config);
  const c = new Console(consoleCommands, config.with({ noAliases: true }));
  return await c.start();
};


/***/ }),

/***/ 789664:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(371017);
const fse = __webpack_require__(655674);

const templates = {
  test: {
    filename: path.join(__dirname, "templates", "example.js"),
    variable: "example"
  },
  contract: {
    filename: path.join(__dirname, "templates", "Example.sol"),
    name: "Example",
    license: "MIT",
    variable: "example"
  },
  migration: {
    filename: path.join(__dirname, "templates", "migration.js")
  }
};

const replaceContents = (filePath, find, replacement) => {
  const data = fse.readFileSync(filePath, { encoding: "utf8" });
  if (typeof find === "string") {
    find = new RegExp(find, "g");
  }
  const result = data.replace(find, replacement);
  fse.writeFileSync(filePath, result, { encoding: "utf8" });
};

const toUnderscoreFromCamel = (string) => {
  string = string.replace(/([A-Z])/g, function ($1) {
    return "_" + $1.toLowerCase();
  });

  if (string[0] === "_") {
    string = string.substring(1);
  }

  return string;
};

// getLicense return the license property value from Truffle config first and
// in case that the file doesn't exist it will fallback to package.json
const getLicense = (options) => {
  try {
    const license = (__webpack_require__(120553).detect)(options).license;
    if (license) {
      return license;
    }
  } catch (err) {
    console.log(err);
  }

  try {
    return __webpack_require__(876775)(path.join(process.cwd(), "package.json")).license;
  } catch {}
};

const Create = {
  contract: function (directory, name, options) {
    const from = templates.contract.filename;
    const to = path.join(directory, name + ".sol");

    if (!options.force && fse.existsSync(to)) {
      throw new Error("Can not create " + name + ".sol: file exists");
    }

    fse.copySync(from, to);

    replaceContents(to, templates.contract.name, name);
    const license = getLicense(options);
    if (license) {
      replaceContents(to, templates.contract.license, license);
    }
  },

  test: function (directory, name, options) {
    let underscored = toUnderscoreFromCamel(name);
    underscored = underscored.replace(/\./g, "_");
    const from = templates.test.filename;
    const to = path.join(directory, underscored + ".js");

    if (!options.force && fse.existsSync(to)) {
      throw new Error("Can not create " + underscored + ".js: file exists");
    }

    fse.copySync(from, to);
    replaceContents(to, templates.contract.name, name);
    replaceContents(to, templates.contract.variable, underscored);
  },

  migration: function (directory, name, options) {
    let underscored = toUnderscoreFromCamel(name || "");
    underscored = underscored.replace(/\./g, "_");
    const from = templates.migration.filename;
    let filename = (new Date().getTime() / 1000) | 0; // Only do seconds.

    if (name != null && name !== "") {
      filename += "_" + underscored;
    }

    filename += ".js";
    const to = path.join(directory, filename);

    if (!options.force && fse.existsSync(to)) {
      throw new Error("Can not create " + filename + ": file exists");
    }
    fse.copySync(from, to);
  }
};

module.exports = Create;


/***/ }),

/***/ 942957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(659442),
  meta: __webpack_require__(646038)
};


/***/ }),

/***/ 659442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const ConfigurationError = __webpack_require__(48937);
  const create = __webpack_require__(789664);

  const config = Config.detect(options);

  let type = config.type;

  if (type == null && config._.length > 0) {
    type = config._[0];
  }

  let name = config.name;

  if (name == null && config._.length > 1) {
    name = config._[1];
  }

  if (type == null) {
    throw new ConfigurationError(
      "Please specify the type of item to create. Example: truffle create contract MyContract"
    );
  }

  if (name == null) {
    throw new ConfigurationError(
      "Please specify the name of item to create. Example: truffle create contract MyContract"
    );
  }

  if (!/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name)) {
    throw new ConfigurationError(
      `The name ${name} is invalid. Please enter a valid name using alpha-numeric characters.`
    );
  }

  const fn = create[type];

  const destinations = {
    contract: config.contracts_directory,
    migration: config.migrations_directory,
    test: config.test_directory
  };

  if (type === "all") {
    for (const key of Object.keys(destinations)) {
      await create[key](destinations[key], name, options);
    }
    return;
  } else if (fn == null) {
    throw new ConfigurationError(`Cannot find creation type: ${type}`);
  } else {
    return create[type](destinations[type], name, options);
  }
};


/***/ }),

/***/ 659602:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(344556),
  meta: __webpack_require__(399608)
};


/***/ }),

/***/ 344556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { detectConfigOrDefault } = __webpack_require__(54708);
  const { DashboardServer } = __webpack_require__(897722);
  const address = __webpack_require__(494849);

  const config = detectConfigOrDefault(options);

  const port = options.port || config.dashboard.port;
  const host = options.host || config.dashboard.host;
  const verbose = options.verbose || config.dashboard.verbose;
  const rpc = true;

  const dashboardServerOptions = { port, host, verbose, rpc };
  const dashboardServer = new DashboardServer(dashboardServerOptions);
  await dashboardServer.start();

  if (host === "0.0.0.0") {
    // Regex taken from react-scripts to check that the address is a private IP, otherwise we discard it
    // https://en.wikipedia.org/wiki/Private_network#Private_IPv4_address_spaces
    let lanAddress =
      /^10[.]|^172[.](1[6-9]|2[0-9]|3[0-1])[.]|^192[.]168[.]/.test(address.ip())
        ? address.ip()
        : undefined;

    console.log(`Truffle Dashboard running at http://localhost:${port}`);
    lanAddress &&
      console.log(`                             http://${lanAddress}:${port}`);

    console.log(
      `DashboardProvider RPC endpoint running at http://localhost:${port}/rpc`
    );
    lanAddress &&
      console.log(
        `                                          http://${lanAddress}:${port}/rpc`
      );
  } else {
    console.log(`Truffle Dashboard running at http://${host}:${port}`);
    console.log(
      `DashboardProvider RPC endpoint running at http://${host}:${port}/rpc`
    );
  }

  // ensure that `await`-ing this method never resolves. (we want to keep
  // the console open until it exits on its own)
  return new Promise(() => {});
};


/***/ }),

/***/ 149797:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(416487),
  meta: __webpack_require__(150111)
};


/***/ }),

/***/ 416487:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const serveCommand = __webpack_require__(243405);
const queryCommand = __webpack_require__(206758);

module.exports = async function (args) {
  const [subCommand] = args._;
  switch (subCommand) {
    case "serve":
      await serveCommand.run(args);
      break;

    case "query":
      await queryCommand.run(args);
      break;

    default:
      console.log(`Unknown command: ${subCommand}`);
  }
};


/***/ }),

/***/ 476463:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(30999),
  meta: __webpack_require__(542285)
};


/***/ }),

/***/ 30999:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { promisify } = __webpack_require__(473837);
  const debugModule = __webpack_require__(615158);
  const loadConfig = __webpack_require__(932);
  const debug = debugModule("lib:commands:debug");

  const { Environment } = __webpack_require__(376765);
  const { CLIDebugger } = __webpack_require__(209941);

  if (options.url && options.network) {
    throw new Error("Url and Network options should not be specified together");
  }

  let config = loadConfig(options);

  await Environment.detect(config);

  const txHash = config._[0]; //may be undefined
  if (config.fetchExternal && txHash === undefined) {
    throw new Error(
      "Fetch-external mode requires a specific transaction to debug"
    );
  }
  if (config.compileTests) {
    config.compileAll = true;
  }
  if (config.compileAll && config.compileNone) {
    throw new Error("Incompatible options passed regarding what to compile");
  }
  const interpreter = await new CLIDebugger(config, { txHash }).run();
  return await promisify(interpreter.start.bind(interpreter))();
};


/***/ }),

/***/ 8230:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(301527),
  meta: __webpack_require__(772041)
};


/***/ }),

/***/ 301527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const runMigrate = __webpack_require__(152423);

module.exports = runMigrate;


/***/ }),

/***/ 355114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(927970),
  meta: __webpack_require__(314957)
};


/***/ }),

/***/ 927970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const emoji = __webpack_require__(858445);
const mnemonicInfo = __webpack_require__(225603);
const {
  configureManagedGanache,
  getFirstDefinedValue
} = __webpack_require__(87088);

const runConsole = async (config, ganacheOptions) => {
  const { Console, excludedCommands } = __webpack_require__(968303);
  const { Environment } = __webpack_require__(376765);

  const commands = __webpack_require__(291874);

  const consoleCommands = commands.reduce((acc, name) => {
    return !excludedCommands.has(name)
      ? Object.assign(acc, { [name]: commands[name] })
      : acc;
  }, {});

  await Environment.develop(config, ganacheOptions);
  const c = new Console(consoleCommands, config.with({ noAliases: true }));
  c.on("exit", () => process.exit());
  return await c.start();
};

module.exports = async options => {
  const { Develop } = __webpack_require__(376765);
  const Config = __webpack_require__(120553);

  const config = Config.detect(options);
  const customConfig = config.networks.develop || {};

  const numberOfAccounts = getFirstDefinedValue(
    customConfig.accounts,
    customConfig.total_accounts,
    10 // Use as default number of accounts
  );
  const { mnemonic, accounts, privateKeys } =
    mnemonicInfo.getAccountsInfo(numberOfAccounts);

  const onMissing = () => "**";

  const warning =
    ":warning:  Important :warning:  : " +
    "This mnemonic was created for you by Truffle. It is not secure.\n" +
    "Ensure you do not use it on production blockchains, or else you risk losing funds.";

  const ipcOptions = { log: options.log };
  const ganacheOptions = configureManagedGanache(
    config,
    customConfig,
    mnemonic
  );

  const { started } = await Develop.connectOrStart(ipcOptions, ganacheOptions);
  const url = `http://${ganacheOptions.host}:${ganacheOptions.port}/`;

  if (started) {
    config.logger.log(`Truffle Develop started at ${url}`);
    config.logger.log();

    config.logger.log(`Accounts:`);
    accounts.forEach((acct, idx) => config.logger.log(`(${idx}) ${acct}`));
    config.logger.log();

    config.logger.log(`Private Keys:`);
    privateKeys.forEach((key, idx) => config.logger.log(`(${idx}) ${key}`));
    config.logger.log();

    config.logger.log(`Mnemonic: ${mnemonic}`);
    config.logger.log();
    config.logger.log(emoji.emojify(warning, onMissing));
    config.logger.log();
  } else {
    config.logger.log(
      `Connected to existing Truffle Develop session at ${url}`
    );
    config.logger.log();
  }

  if (options.log) {
    // leave the process open so that logging can take place
    return new Promise(() => {});
  }
  return await runConsole(config, ganacheOptions);
};


/***/ }),

/***/ 241400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(22888),
  meta: __webpack_require__(781483)
};


/***/ }),

/***/ 22888:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const WorkflowCompile = __webpack_require__(577135);
  const ConfigurationError = __webpack_require__(48937);
  const Require = __webpack_require__(868992);
  const { Environment } = __webpack_require__(376765);
  const path = __webpack_require__(371017);
  const OS = __webpack_require__(822037);
  const { promisify } = __webpack_require__(473837);

  const config = Config.detect(options);

  let file = options.file;

  if (file == null && options._.length > 0) {
    file = options._[0];
  }

  if (file == null) {
    throw new ConfigurationError(
      "Please specify a file, passing the path of the script you'd like the run. Note that all scripts *must* call process.exit() when finished."
    );
  }

  if (path.isAbsolute(file) === false) {
    file = path.join(process.cwd(), file);
  }

  await Environment.detect(config);
  if (config.networkHint !== false) {
    config.logger.log("Using network '" + config.network + "'." + OS.EOL);
  }

  // `--compile`
  let compilationOutput;
  if (options.c || options.compile) {
    compilationOutput = await WorkflowCompile.compile(config);
  }
  // save artifacts if compilation took place
  if (compilationOutput) {
    await WorkflowCompile.save(config, compilationOutput);
  }
  return await promisify(Require.exec.bind(Require))(config.with({ file }));
};


/***/ }),

/***/ 463979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (selectedCommand, subCommand, options) {
  const commands = __webpack_require__(591559);
  const globalCommandOptions = __webpack_require__(467023);

  let commandHelp, commandDescription;

  const chosenCommand = commands[selectedCommand];

  if (subCommand && chosenCommand.subCommands[subCommand]) {
    commandHelp = chosenCommand.subCommands[subCommand].meta.help;
    commandDescription = chosenCommand.subCommands[subCommand].meta.description;
  } else {
    commandHelp = chosenCommand.meta.help;
    commandDescription = chosenCommand.meta.description;
  }

  if (typeof commandHelp === "function") {
    commandHelp = await commandHelp(options);
  }

  const allowedGlobalOptions = commandHelp.allowedGlobalOptions
    .filter(tag => tag in globalCommandOptions)
    .map(tag => globalCommandOptions[tag]);
  const validOptionsUsage = allowedGlobalOptions
    .map(({ option }) => `[${option}]`)
    .join(" ");

  const commandHelpUsage = commandHelp.usage + " " + validOptionsUsage;

  console.log(`\n  Usage:        ${commandHelpUsage}`);
  console.log(`  Description:  ${commandDescription}`);

  if (commandHelp.options.length > 0) {
    const allValidOptions = [...commandHelp.options, ...allowedGlobalOptions];

    console.log(`  Options: `);
    for (const option of allValidOptions) {
      if (option.internal) {
        continue;
      }

      console.log(`                ${option.option}`);
      console.log(`                    ${option.description}`);
    }
  }
  console.log("");
};


/***/ }),

/***/ 909546:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const displayCommandHelp = __webpack_require__(463979);
  const commands = __webpack_require__(591559);
  if (options._.length === 0) {
    await displayCommandHelp("help", options);
    return;
  }
  const selectedCommand = options._[0];
  const subCommand = options._[1];

  if (commands[selectedCommand]) {
    await displayCommandHelp(selectedCommand, subCommand, options);
    return;
  } else {
    console.log(`\n  Cannot find the given command '${selectedCommand}'`);
    console.log("  Please ensure your command is one of the following: ");
    Object.keys(commands)
      .sort()
      .forEach(command => console.log(`      ${command}`));
    console.log("");
    return;
  }
};


/***/ }),

/***/ 591559:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  build: __webpack_require__(523525),
  compile: __webpack_require__(914033),
  config: __webpack_require__(674445),
  console: __webpack_require__(789923),
  create: __webpack_require__(942957),
  dashboard: __webpack_require__(659602),
  db: __webpack_require__(149797),
  debug: __webpack_require__(476463),
  deploy: __webpack_require__(8230),
  develop: __webpack_require__(355114),
  exec: __webpack_require__(241400),
  help: __webpack_require__(867340),
  init: __webpack_require__(429287),
  install: __webpack_require__(270447),
  migrate: __webpack_require__(601827),
  networks: __webpack_require__(399706),
  obtain: __webpack_require__(853017),
  opcode: __webpack_require__(448829),
  preserve: __webpack_require__(796112),
  publish: __webpack_require__(388023),
  run: __webpack_require__(190512),
  test: __webpack_require__(86067),
  unbox: __webpack_require__(72995),
  version: __webpack_require__(669037),
  watch: __webpack_require__(536563)
};


/***/ }),

/***/ 344062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(371017);
const fse = __webpack_require__(655674);
const { promptOverwrites } = __webpack_require__(169751);

const copyFiles = async (destination, options) => {
  fse.ensureDirSync(destination);
  const { force, logger, events } = options;
  const sourcePath = path.join(__dirname, "initSource");
  const projectFiles = fse.readdirSync(sourcePath).filter(
    filename => !filename.endsWith(".eslintrc.json") //exclude .eslintrc.json
  );
  const destinationContents = fse.readdirSync(destination);

  const newContents = projectFiles.filter(
    filename => !destinationContents.includes(filename)
  );

  const contentCollisions = projectFiles.filter(filename =>
    destinationContents.includes(filename)
  );

  let shouldCopy;
  if (force) {
    shouldCopy = projectFiles;
  } else {
    const overwriteContents = await promptOverwrites(contentCollisions, logger);
    shouldCopy = [...newContents, ...overwriteContents];
  }

  await events.emit("init:copyingProjectFiles", {
    destinationPath: destination,
  });
  for (const file of shouldCopy) {
    fse.copySync(path.join(sourcePath, file), path.join(destination, file));
  }
};

module.exports = { copyFiles };


/***/ }),

/***/ 429287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(97509),
  meta: __webpack_require__(383193)
};


/***/ }),

/***/ 169751:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fse = __webpack_require__(655674);
const inquirer = __webpack_require__(496062);

const promptOverwrites = async (contentCollisions, logger = console) => {
  const overwriteContents = [];

  for (const file of contentCollisions) {
    logger.log(`${file} already exists in this directory...`);
    const overwriting = [
      {
        type: "confirm",
        name: "overwrite",
        message: `Overwrite ${file}?`,
        default: false,
      },
    ];

    const { overwrite } = await inquirer.prompt(overwriting);
    if (overwrite) {
      fse.removeSync(file);
      overwriteContents.push(file);
    }
  }

  return overwriteContents;
};

module.exports = { promptOverwrites };


/***/ }),

/***/ 97509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { copyFiles } = __webpack_require__(344062);
  const fse = __webpack_require__(655674);
  const Config = __webpack_require__(120553);
  const config = Config.default();

  let destinationPath;
  if (options._ && options._.length > 0) {
    destinationPath = options._[0];
    fse.ensureDirSync(destinationPath);
  } else {
    destinationPath = config.working_directory;
  }

  const { events } = config;
  events.emit("init:start");

  try {
    await copyFiles(destinationPath, config);
    await events.emit("init:succeed");
  } catch (error) {
    await events.emit("init:fail", { error });
    throw error;
  }
  return;
};


/***/ }),

/***/ 270447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(308515),
  meta: __webpack_require__(472545)
};


/***/ }),

/***/ 308515:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const Package = __webpack_require__(883513);

  if (options._ && options._.length > 0) options.packages = options._;

  const config = Config.detect(options);
  return await Package.install(config);
};


/***/ }),

/***/ 399706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(213018),
  meta: __webpack_require__(741873)
};


/***/ }),

/***/ 213018:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const Networks = __webpack_require__(478979);

  const config = Config.detect(options);

  if (options.clean) {
    return await Networks.clean(config);
  }
  return await Networks.display(config);
};


/***/ }),

/***/ 853017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(334122),
  meta: __webpack_require__(719518)
};


/***/ }),

/***/ 334122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const SUPPORTED_COMPILERS = ["--solc"];
  const Config = __webpack_require__(120553);
  const config = Config.default().with(options);

  config.events.emit("obtain:start");

  if (options.solc) {
    return await downloadAndCacheSolc({ config, options });
  }

  const message =
    `You have specified a compiler that is unsupported by ` +
    `Truffle.\nYou must specify one of the following ` +
    `compilers as well as a version as arguments: ` +
    `${SUPPORTED_COMPILERS.join(", ")}\nSee 'truffle help ` +
    `obtain' for more information and usage.`;
  throw new Error(message);
};

const downloadAndCacheSolc = async ({ config, options }) => {
  const { CompilerSupplier } = __webpack_require__(4273);
  const semver = __webpack_require__(627029);
  const { events } = config;

  const version = options.solc;
  if (!version || !semver.validRange(version)) {
    const message =
      `You must specify a valid solc version to download` +
      `You specified: "${version}".`;
    throw new Error(message);
  }

  try {
    const supplier = new CompilerSupplier({
      events,
      solcConfig: {
        ...config.compilers.solc,
        version
      }
    });
    const { solc } = await supplier.load();
    events.emit("obtain:succeed", {
      compiler: {
        version: solc.version(),
        name: "Solidity"
      }
    });
    return;
  } catch (error) {
    events.emit("obtain:fail");
    return;
  }
};


/***/ }),

/***/ 448829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(186295),
  meta: __webpack_require__(103697)
};


/***/ }),

/***/ 186295:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const TruffleError = __webpack_require__(673321);
  const WorkflowCompile = __webpack_require__(577135);
  const CodeUtils = __webpack_require__(908135);
  const { Conversion } = __webpack_require__(20102);

  if (options._.length === 0) {
    throw new TruffleError("Please specify a contract name.");
  }

  const config = Config.detect(options);
  await WorkflowCompile.compileAndSave(config);
  const contractName = options._[0];
  let Contract;
  try {
    Contract = config.resolver.require(contractName);
  } catch (e) {
    throw new TruffleError(
      'Cannot find compiled contract with name "' + contractName + '"'
    );
  }

  let bytecode = Contract.deployedBytecode;
  let numInstructions = Contract.deployedSourceMap.split(";").length;

  if (options.creation) {
    bytecode = Contract.bytecode;
    numInstructions = Contract.sourceMap.split(";").length;
  }
  const opcodes = CodeUtils.parseCode(bytecode, numInstructions);

  if (opcodes.length === 0) {
    console.log(
      "Contract has no bytecode. Please check to make sure it's not an `abstract contract` or an `interface`."
    );
    return;
  }

  const lastPCByteLength = Conversion.toBytes(
    opcodes[opcodes.length - 1].pc
  ).byteLength;

  opcodes.forEach(opcode => {
    console.log(
      Conversion.toHexString(opcode.pc, lastPCByteLength) + ":",
      opcode.name,
      opcode.pushData || ""
    );
  });
};


/***/ }),

/***/ 796112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(322954),
  meta: __webpack_require__(639175)
};


/***/ }),

/***/ 322954:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async options => {
  const TruffleError = __webpack_require__(673321);
  const { Plugins } = __webpack_require__(342113);
  const { getConfig, constructRecipes } = __webpack_require__(361914);
  const { preserve, ConsoleReporter } = __webpack_require__(805810);
  const semver = __webpack_require__(627029);

  if (!semver.satisfies(process.version, ">=12")) {
    throw new TruffleError(
      `The current version of Node (${process.version}) does not support \`truffle preserve\`, please update to Node >=12`
    );
  }

  const config = getConfig(options);

  const environments = config.environments || {};

  if (config.environment && !(config.environment in environments)) {
    throw new TruffleError(
      `Unknown environment: ${config.environment}. Check your truffle-config.js?`
    );
  }

  const plugins = Plugins.listAllRecipes(config);
  const environment = environments[config.environment || "development"];
  const recipes = constructRecipes(plugins, environment);

  // check for tag in options (instead of config, for maybe extra safety)
  const recipePlugin = plugins.find(plugin => plugin.tag in options);

  if (!recipePlugin) {
    throw new TruffleError("No (valid) recipe specified");
  }

  const [recipe] = constructRecipes([recipePlugin], environment);

  if (config._.length === 0) {
    throw new TruffleError("No preserve target specified");
  }

  for (const path of config._) {
    config.logger.log();
    const message = `Preserving target: ${path}`;
    config.logger.log(message);
    config.logger.log("=".repeat(message.length));

    const reporter = new ConsoleReporter({ console: config.logger });

    // The specified path and the truffle config are passed as initial inputs
    // that can be used by any recipe.
    const inputs = { path, config };

    await reporter.report(
      preserve({
        recipes,
        request: { recipe, inputs }
      })
    );

    config.logger.log();
  }
};


/***/ }),

/***/ 388023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(822986),
  meta: __webpack_require__(939662)
};


/***/ }),

/***/ 822986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const Package = __webpack_require__(883513);

  const config = Config.detect(options);
  return await Package.publish(config);
};


/***/ }),

/***/ 443736:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const TruffleError = __webpack_require__(673321);

const checkPluginConfig = ({ plugins }) => {
  if (!plugins) {
    throw new TruffleError(
      "\nError: No plugins detected in the configuration file.\n"
    );
  }

  if (!Array.isArray(plugins) || plugins.length === 0) {
    throw new TruffleError("\nError: Plugins configured incorrectly.\n");
  }
};

module.exports = {
  checkPluginConfig
};


/***/ }),

/***/ 14864:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async options => {
  const Run = __webpack_require__(77928);
  const { promisify } = __webpack_require__(473837);
  const Config = __webpack_require__(120553);
  const { checkPluginConfig } = __webpack_require__(443736);
  const config = Config.detect(options);

  if (options._.length === 0) {
    const { displayCommandHelp } = __webpack_require__(867340);
    await displayCommandHelp("run");
    return;
  }

  const customCommand = options._[0];

  checkPluginConfig(config);

  return await promisify(Run.run.bind(Run))(customCommand, config);
};


/***/ }),

/***/ 77928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Plugins } = __webpack_require__(342113);
const TruffleError = __webpack_require__(673321);

const Run = {
  // executes command or throws user helpful error
  run(customCommand, config, done) {
    const [foundPlugin] = Plugins.findPluginsForCommand(config, customCommand);

    if (!foundPlugin) {
      throw new TruffleError(
        `\nError: "${customCommand}" command not supported by any currently configured plugins. Please make sure:
  – plugins are correctly configured in truffle-config.js
  – the plugin supporting the command you want to use is installed\n`
      );
    }

    // Will throw an error if loading fails, indicating misconfiguration
    const runCommand = foundPlugin.loadCommand(customCommand);

    const commandResult = runCommand(config, done);
    if (commandResult && typeof commandResult.then === "function") {
      commandResult.then(() => done()).catch(err => done(err));
    }
  }
};

module.exports = Run;


/***/ }),

/***/ 193622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const copyArtifactsToTempDir = async config => {
  const fse = __webpack_require__(655674);
  const OS = __webpack_require__(822037);
  const tmp = __webpack_require__(336276);
  tmp.setGracefulCleanup();

  // Copy all the built files over to a temporary directory, because we
  // don't want to save any tests artifacts. Only do this if the build directory
  // exists.
  const temporaryDirectory = tmp.dirSync({
    unsafeCleanup: true,
    prefix: "test-"
  }).name;
  try {
    fse.statSync(config.contracts_build_directory);
  } catch (_error) {
    return { temporaryDirectory };
  }

  fse.copySync(config.contracts_build_directory, temporaryDirectory);

  if (config.runnerOutputOnly !== true) {
    config.logger.log("Using network '" + config.network + "'." + OS.EOL);
  }
  return { temporaryDirectory };
};

module.exports = {
  copyArtifactsToTempDir
};


/***/ }),

/***/ 613799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const determineTestFilesToRun = ({ inputFile, inputArgs = [], config }) => {
  const path = __webpack_require__(371017);
  const fs = __webpack_require__(657147);
  const glob = __webpack_require__(312884);
  let filesToRun = [];

  if (inputFile) {
    filesToRun.push(inputFile);
  } else if (inputArgs.length > 0) {
    inputArgs.forEach(inputArg => filesToRun.push(inputArg));
  }

  if (filesToRun.length === 0) {
    const directoryContents = glob.sync(
      `${config.test_directory}${path.sep}**${path.sep}*`
    );
    filesToRun =
      directoryContents.filter(item => fs.statSync(item).isFile()) || [];
  }
  return filesToRun.filter(file => {
    return file.match(config.test_file_extension_regexp) !== null;
  });
};

module.exports = {
  determineTestFilesToRun
};


/***/ }),

/***/ 86067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(446394),
  meta: __webpack_require__(43059)
};


/***/ }),

/***/ 955472:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const prepareConfigAndRunTests = ({ config, temporaryDirectory, files }) => {
  const Artifactor = __webpack_require__(529463);
  const Test = __webpack_require__(952422);
  // Set a new artifactor; don't rely on the one created by Environments.
  // TODO: Make the test artifactor configurable.
  config.artifactor = new Artifactor(temporaryDirectory);

  const testConfig = config.with({
    test_files: files,
    contracts_build_directory: temporaryDirectory
  });
  return Test.run(testConfig);
};

module.exports = {
  prepareConfigAndRunTests
};


/***/ }),

/***/ 446394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parseCommandLineFlags = options => {
  // parse out command line flags to merge in to the config
  const grep = options.grep || options.g;
  const bail = options.bail || options.b;
  const reporter = options.reporter || options.r;

  /**
   * Reporter value passed on the command line has precedence over a reporter value in the config.
   * If neither exist, then nothing is passed to mocha and it uses its default reporter type "spec".
   * Note: It is important that reporter be completely omitted, and not be set to undefined!
   * As setting it to undefined will ignore the reporter value specified in the config.
   */
  return reporter === undefined
    ? { mocha: { grep, bail } }
    : { mocha: { grep, bail, reporter } };
};

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const { Environment, Develop } = __webpack_require__(376765);
  const { copyArtifactsToTempDir } = __webpack_require__(193622);
  const { determineTestFilesToRun } = __webpack_require__(613799);
  const { prepareConfigAndRunTests } = __webpack_require__(955472);
  const { configureManagedGanache } = __webpack_require__(87088);

  const optionsToMerge = parseCommandLineFlags(options);
  const config = Config.detect(options).merge(optionsToMerge);

  // if "development" exists, default to using that for testing
  if (!config.network && config.networks.development) {
    config.network = "development";
  }

  if (!config.network) {
    config.network = "test";
  } else {
    await Environment.detect(config);
  }

  // Start managed ganache network
  async function startGanacheAndRunTests(ipcOptions, ganacheOptions, config) {
    const { disconnect } = await Develop.connectOrStart(
      ipcOptions,
      ganacheOptions
    );
    const ipcDisconnect = disconnect;
    await Environment.develop(config, ganacheOptions);
    const { temporaryDirectory } = await copyArtifactsToTempDir(config);
    const numberOfFailures = await prepareConfigAndRunTests({
      config,
      files,
      temporaryDirectory
    });
    ipcDisconnect();
    return numberOfFailures;
  }

  if (config.stacktraceExtra) {
    config.stacktrace = true;
    config.compileAllDebug = true;
  }
  // enables in-test debug() interrupt, or stacktraces, forcing compileAll
  if (config.debug || config.stacktrace || config.compileAllDebug) {
    config.compileAll = true;
  }

  const { file } = options;
  const inputArgs = options._;
  const files = determineTestFilesToRun({
    config,
    inputArgs,
    inputFile: file
  });

  const configuredNetwork = config.networks[config.network];
  const testNetworkDefinedAndUsed =
    configuredNetwork && config.network === "test";
  const noProviderHostOrUrlConfigured =
    configuredNetwork &&
    !configuredNetwork.provider &&
    !configuredNetwork.host &&
    !configuredNetwork.url;
  let numberOfFailures;

  if (
    (testNetworkDefinedAndUsed && noProviderHostOrUrlConfigured) ||
    !configuredNetwork
  ) {
    const defaultPort = await __webpack_require__(715959)();
    const defaultMnemonic =
      "candy maple cake sugar pudding cream honey rich smooth crumble sweet treat";
    // configuredNetwork will spread only when it is defined and ignored when undefined
    const managedNetworkOptions = {
      port: defaultPort,
      ...configuredNetwork
    };

    const mnemonic = managedNetworkOptions.mnemonic || defaultMnemonic;
    const ganacheOptions = configureManagedGanache(
      config,
      managedNetworkOptions,
      mnemonic
    );

    const ipcOptions = { network: "test" };
    numberOfFailures = await startGanacheAndRunTests(
      ipcOptions,
      ganacheOptions,
      config
    );
  } else {
    // Use unmanaged network with user specified config if provider, host or url exists
    await Environment.detect(config);
    const { temporaryDirectory } = await copyArtifactsToTempDir(config);
    numberOfFailures = await prepareConfigAndRunTests({
      config,
      files,
      temporaryDirectory
    });
  }
  return numberOfFailures;
};


/***/ }),

/***/ 72995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(591283),
  meta: __webpack_require__(474292)
};


/***/ }),

/***/ 591283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const normalizeDestination = (destination, workingDirectory) => {
  if (!destination) {
    return workingDirectory;
  }
  const path = __webpack_require__(371017);
  if (path.isAbsolute(destination)) return destination;
  return path.join(workingDirectory, destination);
};

module.exports = async options => {
  const Config = __webpack_require__(120553);
  const { default: Box } = __webpack_require__(221579);
  const fse = __webpack_require__(655674);

  const config = Config.default().with({ logger: console });
  // we merge in the options so that options passed on the command line
  // (for example --quiet) make it to the EventManager
  config.merge(options);

  let [url, destination] = options._;

  const normalizedDestination = normalizeDestination(
    destination,
    config.working_directory
  );

  fse.ensureDirSync(normalizedDestination);

  const unboxOptions = Object.assign({}, options, { logger: config.logger });

  config.events.emit("unbox:start");

  const boxConfig = await Box.unbox(
    url,
    normalizedDestination,
    unboxOptions,
    config
  );
  await config.events.emit("unbox:succeed", { boxConfig });
};


/***/ }),

/***/ 669037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(887365),
  meta: __webpack_require__(974770)
};


/***/ }),

/***/ 887365:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { detectConfigOrDefault } = __webpack_require__(54708);
  const version = __webpack_require__(64146);
  const { logger } = options;

  const config = detectConfigOrDefault(options);

  version.logAll(logger, config);
  return;
};


/***/ }),

/***/ 536563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(915088),
  meta: __webpack_require__(847766)
};


/***/ }),

/***/ 915088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const colors = __webpack_require__(183196);
const commandExistsSync = (__webpack_require__(905497).sync);

module.exports = async function (options) {
  const OS = __webpack_require__(822037);
  const deprecationMessage = colors.yellow(
    `> The watch command is planned ` +
      `for deprecation in version 6 of Truffle.${OS.EOL}` +
      `> See https://github.com/trufflesuite/truffle/issues/3227 for more ` +
      `information.`
  );
  console.log(deprecationMessage);
  const Config = __webpack_require__(120553);
  const sane = __webpack_require__(252817);
  const path = __webpack_require__(371017);

  const config = Config.detect(options);

  const watchOptions = {
    ignored: [
      "build/**/**",
      /[/\\]\./ // Ignore files prefixed with .
    ]
  };
  // Certain large codebases have trouble with the watch command.
  // Installing watchman resolves some of these issues.
  if (commandExistsSync("watchman")) {
    watchOptions.watchman = true;
  } else {
    config.logger.log(
      "If you have trouble using watch, try installing watchman."
    );
  }

  const watchCallback = filePath => {
    const displayPath = path.join(
      "./",
      filePath.replace(config.working_directory, "")
    );
    config.logger.log(colors.cyan(">> File " + displayPath + " changed."));

    build(config);
  };

  const watcher = sane(config.working_directory, watchOptions);
  watcher.on("change", watchCallback);
  watcher.on("add", watchCallback);
  watcher.on("delete", watchCallback);

  config.logger.log(colors.green("Watching for a change in project files..."));
  return new Promise(() => {});
};

const build = config => {
  const Build = __webpack_require__(523525);

  config.logger.log("Rebuilding...");

  Build.build(config, function (error) {
    printSummary(config, error);
  });
};

const printSummary = (config, error) => {
  if (error) {
    const TruffleError = __webpack_require__(673321);
    if (error instanceof TruffleError) {
      console.log(error.message);
    } else {
      // Bubble up all other unexpected errors.
      console.log(error.stack || error.toString());
    }
  } else {
    config.logger.log(
      colors.green("Completed without errors on " + new Date().toString())
    );
  }
};


/***/ }),

/***/ 87088:
/***/ ((module) => {

function resolveNetworkId(network_id) {
  // Use default network_id if "*" is defined in config
  if (network_id === "*") {
    return Date.now();
  }

  const parsedNetworkId = parseInt(network_id, 10);
  if (isNaN(parsedNetworkId)) {
    const error =
      `The network id specified in the truffle config ` +
      `(${network_id}) is not valid. Please properly configure the network id as an integer value.`;
    throw new Error(error);
  }

  return parsedNetworkId;
}

// This function returns the first defined argument value
const getFirstDefinedValue = (...values) =>
  values.find(value => value !== undefined);

function configureManagedGanache(config, networkConfig, mnemonic) {
  const host = getFirstDefinedValue(
    networkConfig.host,
    "127.0.0.1" // Use as default host
  );

  const port = getFirstDefinedValue(
    networkConfig.port,
    9545 // Use as default port
  );

  const network_id = getFirstDefinedValue(
    networkConfig.network_id,
    5777 // Use as default network_id
  );
  const resolvedNetworkId = resolveNetworkId(network_id);

  const total_accounts = getFirstDefinedValue(
    networkConfig.accounts,
    networkConfig.total_accounts,
    10 // Use as default number of accounts
  );

  const default_balance_ether = getFirstDefinedValue(
    networkConfig.defaultEtherBalance,
    networkConfig.default_balance_ether,
    100 // Use as default ether balance for each account
  );

  const blockTime = getFirstDefinedValue(
    networkConfig.blockTime,
    0 // Use as default block time
  );

  const gasLimit = getFirstDefinedValue(
    networkConfig.gasLimit,
    0x6691b7 // Use as default gasLimit
  );

  const gasPrice = getFirstDefinedValue(
    networkConfig.gasPrice,
    0x77359400 // Use default gas price 2000000000 wei
  );

  const genesisTime = getFirstDefinedValue(
    // Higher precedence is given to the networkConfig.time or networkConfig.genesis_time
    networkConfig.time,
    networkConfig.genesis_time,
    config.time,
    config.genesis_time
  );

  const fork = networkConfig.fork;
  const hardfork = networkConfig.hardfork;

  const ganacheOptions = {
    host,
    port,
    network_id: resolvedNetworkId,
    total_accounts,
    default_balance_ether,
    blockTime,
    fork,
    hardfork,
    mnemonic,
    gasLimit,
    gasPrice,
    time: genesisTime,
    miner: {
      instamine: "strict"
    }
  };

  return ganacheOptions;
}

module.exports = { configureManagedGanache, getFirstDefinedValue };


/***/ }),

/***/ 968303:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const repl = __webpack_require__(438102);
const provision = __webpack_require__(207702);
const {
  Web3Shim,
  createInterfaceAdapter
} = __webpack_require__(936339);
const contract = __webpack_require__(378883);
const vm = __webpack_require__(626144);
const expect = __webpack_require__(414096);
const TruffleError = __webpack_require__(673321);
const fse = __webpack_require__(655674);
const path = __webpack_require__(371017);
const EventEmitter = __webpack_require__(582361);
const spawnSync = (__webpack_require__(532081).spawnSync);
const Require = __webpack_require__(868992);
const debug = __webpack_require__(615158)("console");
const { getCommand } = __webpack_require__(334763);

const processInput = input => {
  const inputComponents = input.trim().split(" ");
  if (inputComponents.length === 0) return input;

  if (inputComponents[0] === "truffle") {
    return inputComponents.slice(1).join(" ");
  }
  return input.trim();
};

class Console extends EventEmitter {
  constructor(tasks, options) {
    super();
    EventEmitter.call(this);

    expect.options(options, [
      "working_directory",
      "contracts_directory",
      "contracts_build_directory",
      "migrations_directory",
      "networks",
      "network",
      "network_id",
      "provider",
      "resolver",
      "build_directory"
    ]);

    this.options = options;

    this.repl = null;

    this.interfaceAdapter = createInterfaceAdapter({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });
    this.web3 = new Web3Shim({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });
  }

  async start() {
    try {
      // start the repl with an empty prompt and show a proper one when
      // the repl has set up its context and is ready to accept input
      this.repl = repl.start({
        prompt: "",
        eval: this.interpret.bind(this)
      });

      // Get and set Truffle and User Globals
      const truffleAndUserGlobals = await this.calculateTruffleAndUserGlobals();
      Object.entries(truffleAndUserGlobals).forEach(([key, value]) => {
        this.repl.context[key] = value;
      });

      // repl is ready - set and display prompt
      this.repl.setPrompt("truffle(" + this.options.network + ")> ");
      this.repl.displayPrompt();

      // hydrate the environment with the user's contracts
      this.provision();

      this.repl.on("exit", () => {
        process.exit();
      });

      // ensure that `await`-ing this method never resolves. (we want to keep
      // the console open until it exits on its own)
      return new Promise(() => {});
    } catch (error) {
      this.options.logger.log(
        "Unexpected error setting up the environment or provisioning " +
          "contracts while instantiating the console."
      );
      this.options.logger.log(error.stack || error.message || error);
    }
  }

  getUserDefinedGlobals({ accounts, interfaceAdapter, web3 }) {
    // exit if feature should be disabled
    if (this.options["require-none"]) return;

    // exit if no hydrate options are set
    if (
      (!this.options.console || !this.options.console.require) &&
      !this.options.require &&
      !this.options.r
    )
      return;

    const addToContext = (context, userData, namespace) => {
      for (const key in userData) {
        if (namespace) {
          if (typeof context[namespace] === "undefined") {
            context[namespace] = {};
          }
          context[namespace][key] = userData[key];
        } else {
          context[key] = userData[key];
        }
      }
    };
    const errorMessage =
      "You must specify the console.require property as " +
      "either a string or an array. If you specify an array, its members " +
      "must be paths or objects containing at least a `path` property.";

    const requireValue =
      this.options.r || this.options.require || this.options.console.require;

    // Require allows us to inject Truffle variables into the script's scope
    const requireOptions = {
      context: {
        accounts,
        interfaceAdapter,
        web3
      }
    };
    const userGlobals = {};
    if (typeof requireValue === "string") {
      requireOptions.file = requireValue;
      addToContext(userGlobals, Require.file(requireOptions));
    } else if (Array.isArray(requireValue)) {
      this.options.console.require.forEach(item => {
        if (typeof item === "string") {
          requireOptions.file = item;
          addToContext(userGlobals, Require.file(requireOptions));
        } else if (typeof item === "object" && item.path) {
          requireOptions.file = item.path;
          addToContext(userGlobals, Require.file(requireOptions), item.as);
        } else {
          throw new Error(errorMessage);
        }
      });
    } else {
      throw new Error(errorMessage);
    }
    return userGlobals;
  }

  async calculateTruffleAndUserGlobals() {
    let accounts;
    try {
      accounts = await this.interfaceAdapter.getAccounts();
    } catch {
      // don't prevent Truffle from working if user doesn't provide some way
      // to sign transactions (e.g. no reason to disallow debugging)
      accounts = [];
    }

    const userGlobals = this.getUserDefinedGlobals({
      web3: this.web3,
      interfaceAdapter: this.interfaceAdapter,
      accounts
    });

    const truffleGlobals = {
      web3: this.web3,
      interfaceAdapter: this.interfaceAdapter,
      accounts
    };

    // we insert user variables first so as to not clobber Truffle's
    return {
      ...userGlobals,
      ...truffleGlobals
    };
  }

  provision() {
    let files;
    try {
      const unfilteredFiles = fse.readdirSync(
        this.options.contracts_build_directory
      );
      files = unfilteredFiles.filter(file => file.endsWith(".json"));
    } catch (error) {
      // Error reading the build directory? Must mean it doesn't exist or we don't have access to it.
      // Couldn't provision the contracts if we wanted. It's possible we're hiding very rare FS
      // errors, but that's better than showing the user error messages that will be "build folder
      // doesn't exist" 99.9% of the time.
    }

    let jsonBlobs = [];
    files = files || [];

    files.forEach(file => {
      try {
        const body = fse.readFileSync(
          path.join(this.options.contracts_build_directory, file),
          "utf8"
        );
        jsonBlobs.push(JSON.parse(body));
      } catch (error) {
        throw new Error(`Error parsing or reading ${file}: ${error.message}`);
      }
    });

    const abstractions = jsonBlobs.map(json => {
      const abstraction = contract(json);
      provision(abstraction, this.options);
      return abstraction;
    });

    this.resetContractsInConsoleContext(abstractions);
    return abstractions;
  }

  resetContractsInConsoleContext(abstractions) {
    abstractions = abstractions || [];

    const contextVars = {};

    abstractions.forEach(abstraction => {
      contextVars[abstraction.contract_name] = abstraction;
    });

    // make sure the repl gets the new contracts in its context
    Object.keys(contextVars || {}).forEach(key => {
      this.repl.context[key] = contextVars[key];
    });
  }

  runSpawn(inputStrings, options) {
    let childPath;
    /* eslint-disable no-undef */
    if (true) {
      childPath = path.join(__dirname, "consoleChild.bundled.js");
    } else {}

    // stderr is piped here because we don't need to repeatedly see the parent
    // errors/warnings in child process - specifically the error re: having
    // multiple config files
    const spawnOptions = { stdio: ["inherit", "inherit", "pipe"] };
    const settings = ["config", "network", "url"]
      .filter(setting => options[setting])
      .map(setting => `--${setting} ${options[setting]}`)
      .join(" ");

    const spawnInput = `${settings} -- ${inputStrings}`;

    const spawnResult = spawnSync(
      "node",
      ["--no-deprecation", childPath, spawnInput],
      spawnOptions
    );

    if (spawnResult.stderr) {
      // Theoretically stderr can contain multiple errors.
      // So let's just print it instead of throwing through
      // the error handling mechanism. Bad call?
      debug(spawnResult.stderr.toString());
    }

    // re-provision to ensure any changes are available in the repl
    this.provision();

    //display prompt when child repl process is finished
    this.repl.displayPrompt();
  }

  interpret(input, context, filename, callback) {
    // processInput returns a sanitized string
    const processedInput = processInput(input);
    if (
      getCommand({
        inputStrings: processedInput.split(" "),
        options: {},
        noAliases: this.options.noAliases
      }) !== null
    ) {
      try {
        this.runSpawn(processedInput, this.options);
      } catch (error) {
        // Perform error handling ourselves.
        if (error instanceof TruffleError) {
          console.log(error.message);
        } else {
          // Bubble up all other unexpected errors.
          console.log(error.stack || error.toString());
        }
        return callback();
      }

      // Reprovision after each command as it may change contracts.
      try {
        this.provision();
        return callback();
      } catch (error) {
        // Don't pass abstractions to the callback if they're there or else
        // they'll get printed in the repl.
        return callback(error);
      }
    }

    // Much of the following code is from here, though spruced up:
    // https://github.com/nfcampos/await-outside

    /*
    - allow whitespace before everything else
    - optionally capture `var|let|const <varname> = `
      - varname only matches if it starts with a-Z or _ or $
        and if contains only those chars or numbers
      - this is overly restrictive but is easier to maintain
    - capture `await <anything that follows it>`
    */
    let includesAwait =
      /^\s*((?:(?:var|const|let)\s+)?[a-zA-Z_$][0-9a-zA-Z_$]*\s*=\s*)?(\(?\s*await[\s\S]*)/;

    const match = processedInput.match(includesAwait);
    let source = processedInput;
    let assignment = null;

    // If our code includes an await, add special processing to ensure it's evaluated properly.
    if (match) {
      let assign = match[1];

      const expression =
        match[2] && match[2].endsWith(";")
          ? // strip off trailing ";" to prevent the expression below from erroring
            match[2].slice(0, -1)
          : match[2];

      const RESULT = "__await_outside_result";

      // Wrap the await inside an async function.
      // Strange indentation keeps column offset correct in stack traces
      source = `(async function() { try { ${
        assign ? `global.${RESULT} =` : "return"
      } (
  ${expression.trim()}
  ); } catch(e) { global.ERROR = e; throw e; } }())`;

      assignment = assign
        ? `${assign.trim()} global.${RESULT}; void delete global.${RESULT};`
        : null;
    }

    const runScript = script => {
      const options = {
        displayErrors: true,
        breakOnSigint: true,
        filename: filename
      };

      vm.createContext(context);
      return script.runInContext(context, options);
    };

    let script;
    try {
      const options = { displayErrors: true, lineOffset: -1 };
      script = vm.createScript(source, options);
    } catch (error) {
      // If syntax error, or similar, bail.
      return callback(error);
    }

    // Ensure our script returns a promise whether we're using an
    // async function or not. If our script is an async function,
    // this will ensure the console waits until that await is finished.
    Promise.resolve(runScript(script))
      .then(value => {
        // If there's an assignment to run, run that.
        if (assignment) return runScript(vm.createScript(assignment));
        return value;
      })
      .then(value => {
        // All good? Return the value (e.g., eval'd script or assignment)
        callback(null, value);
      })
      .catch(callback);
  }
}

const excludedCommands = new Set(["console", "db", "init", "watch", "develop"]);

module.exports = {
  excludedCommands,
  Console
};


/***/ }),

/***/ 209941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { CLIDebugger } = __webpack_require__(900458);

module.exports = {
  CLIDebugger
};


/***/ }),

/***/ 142863:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const colors = __webpack_require__(183196);
const TruffleError = __webpack_require__(673321);

class BuildError extends TruffleError {
  constructor(message) {
    message =
      "Error building:\n\n" +
      message +
      "\n\n" +
      colors.red("Build failed. See above.");
    super(message);
  }
}

module.exports = BuildError;


/***/ }),

/***/ 48937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TruffleError = __webpack_require__(673321);

class ConfigurationError extends TruffleError {
  constructor(message) {
    super(message);
  }
}

module.exports = ConfigurationError;


/***/ }),

/***/ 932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = function (options) {
  const Config = __webpack_require__(120553);
  const TruffleError = __webpack_require__(673321);
  const mergeConfigNetwork = __webpack_require__(622173);

  let config;
  try {
    config = Config.detect(options);
    config = mergeConfigNetwork(config, options);
  } catch (error) {
    if (error instanceof TruffleError && options.url) {
      config = Config.default();
      config = mergeConfigNetwork(config, options);
      // in case config file is not detected (exception thrown) AND url is provided in the options,
      // We use default config and set compileNone to true. Since there are is no config files and url is provided,
      // It is assumed that truffle debug/console is being used for analysis and debugging and that there is nothing to compile.
      // E.g. analysing/debugging a single transaction of an external project
      config.compileNone = true;
      config.configFileSkipped = true;
    } else {
      throw error;
    }
  }

  return config;
};


/***/ }),

/***/ 622173:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { URL } = __webpack_require__(257310);

module.exports = function (config, options) {
  if (options.url) {
    const url = new URL(options.url);
    config.networks[url.host] = {
      url: options.url,
      network_id: "*"
    };
    config.network = url.host;
  }
  config.merge(options);
  return config;
};


/***/ }),

/***/ 225603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @module mnemonic;
 * @requires module:@truffle/config
 * @requires module:seedrandom
 * @requires module:ethereum-cryptography
 * @requires module:ethereumjs-wallet/hdkey
 * @requires module:crypto
 */

const Config = __webpack_require__(120553);
const defaultUserConfig = Config.getUserConfig();
const {
  entropyToMnemonic,
  mnemonicToSeedSync
} = __webpack_require__(389211);
const { wordlist } = __webpack_require__(648732);
const { hdkey } = __webpack_require__(938427);
const crypto = __webpack_require__(706113);

const mnemonic = {
  /**
   * gets user-level mnemonic from user config, and if missing generates a new mnemonic
   * @returns {String} mnemonic
   */
  getOrGenerateMnemonic: function () {
    let mnemonic;
    const userMnemonicExists = defaultUserConfig.get("mnemonic");
    if (!userMnemonicExists) {
      mnemonic = entropyToMnemonic(crypto.randomBytes(16), wordlist);
      defaultUserConfig.set({ mnemonic: mnemonic });
    } else {
      mnemonic = userMnemonicExists;
    }

    return mnemonic;
  },

  /**
   * gets accounts object using mnemonic
   * @param {String}
   * @returns {Object} mnemonicObject
   */
  getAccountsInfo: function (numAddresses) {
    let mnemonic = this.getOrGenerateMnemonic();
    let accounts = [];
    let privateKeys = [];

    let hdwallet = hdkey.fromMasterSeed(
      Buffer.from(mnemonicToSeedSync(mnemonic))
    );
    let addressIndex = 0;
    let walletHdpath = "m/44'/60'/0'/0/";

    for (let i = addressIndex; i < addressIndex + numAddresses; i++) {
      let wallet = hdwallet.derivePath(walletHdpath + i).getWallet();
      let addr = "0x" + wallet.getAddress().toString("hex");
      let privKey = wallet.getPrivateKey().toString("hex");
      accounts.push(addr);
      privateKeys.push(privKey);
    }

    return {
      mnemonic,
      accounts,
      privateKeys
    };
  }
};

module.exports = mnemonic;


/***/ }),

/***/ 478979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(657147);
const path = __webpack_require__(371017);
const OS = __webpack_require__(822037);
const BlockchainUtils = __webpack_require__(986317);
const Provider = __webpack_require__(200509);
const { createInterfaceAdapter } = __webpack_require__(936339);

const Networks = {
  deployed: async function(options) {
    let files;
    try {
      // Only read JSON files in directory
      files = fs
        .readdirSync(options.contracts_build_directory)
        .filter(fn => fn.endsWith(".json"));
    } catch (error) {
      // We can't read the directory. Act like we found nothing.
      files = [];
    }

    const binaries = files.map(file => {
      const filePath = path.join(options.contracts_build_directory, file);
      const fileContents = fs.readFileSync(filePath, "utf8");
      return JSON.parse(fileContents);
    });

    const idsToNames = {};
    const networks = {};

    for (let networkName in options.networks) {
      const network = options.networks[networkName];
      const networkId = network.network_id;

      if (networkId == null) return;

      idsToNames[networkId] = networkName;
      networks[networkName] = {};
    }

    for (let json of binaries) {
      for (let networkId in json.networks) {
        const networkName = idsToNames[networkId] || networkId;

        if (networks[networkName] == null) networks[networkName] = {};

        const address = json.networks[networkId].address;

        if (address == null) return;

        networks[networkName][json.contractName] = address;
      }
    }
    return networks;
  },

  display: async function(config) {
    const networks = await this.deployed(config);
    const { networkNames, starNetworks } = Object.keys(networks)
      .sort()
      .reduce(
        (acc, networkName) => {
          if (
            config.networks[networkName] &&
            config.networks[networkName].network_id === "*"
          ) {
            acc.starNetworks.push(networkName);
          } else {
            acc.networkNames.push(networkName);
          }
          return acc;
        },
        { networkNames: [], starNetworks: [] }
      );

    const unknownNetworks = networkNames.filter(networkName => {
      const configuredNetworks = Object.keys(config.networks);
      let found = false;
      for (let i = 0; i < configuredNetworks.length; i++) {
        const configuredNetworkName = configuredNetworks[i];
        if (networkName === configuredNetworkName) {
          found = true;
          break;
        }
      }

      return !found;
    });

    // Only display this warning if:
    //
    //   At least one network is configured with the wildcard ('*') network id
    //   There's a least one network deployed to
    //   And one of those networks deployed to is unknown (i.e., unconfigured).
    if (
      starNetworks.length > 0 &&
      networkNames.length > 0 &&
      unknownNetworks.length > 0
    ) {
      config.logger.log(
        OS.EOL +
          "The following networks are configured to match any network id ('*'):" +
          OS.EOL
      );

      starNetworks.forEach(networkName => {
        config.logger.log("    " + networkName);
      });

      config.logger.log(
        OS.EOL +
          "Closely inspect the deployed networks below, and use `truffle networks --clean` to remove any networks that don't match your configuration. You should not use the wildcard configuration ('*') for staging and production networks for which you intend to deploy your application."
      );
    }

    networkNames.forEach(networkName => {
      config.logger.log("");

      let output = Object.keys(networks[networkName])
        .sort()
        .map(contract_name => {
          const address = networks[networkName][contract_name];
          return contract_name + ": " + address;
        });

      if (output.length === 0) output = ["No contracts deployed."];

      let message = "Network: ";

      const is_id = config.networks[networkName] == null;

      if (is_id) {
        message += "UNKNOWN (id: " + networkName + ")";
      } else {
        message +=
          networkName +
          " (id: " +
          config.networks[networkName].network_id +
          ")";
      }

      config.logger.log(message);
      config.logger.log("  " + output.join("\n  "));
    });

    if (networkNames.length === 0) {
      config.logger.log(
        OS.EOL + "Contracts have not been deployed to any network."
      );
    }
    config.logger.log("");
  },

  clean: async function(config) {
    // Only read JSON files in directory
    let files = fs
      .readdirSync(config.contracts_build_directory)
      .filter(fn => fn.endsWith(".json"));
    const configuredNetworks = Object.keys(config.networks);
    const results = [];

    files.forEach(file => {
      const filePath = path.join(config.contracts_build_directory, file);
      const fileContents = fs.readFileSync(filePath, "utf8");
      const body = JSON.parse(fileContents);

      for (let installedNetworkId of Object.keys(body.networks)) {
        let found = false;
        for (let i = 0; i < configuredNetworks.length; i++) {
          const configuredNetwork = configuredNetworks[i];

          // If an installed network id matches a configured id, then we can ignore this one.
          let parsedNetworkId;
          try {
            // Account for an integer or string in the config
            parsedNetworkId = parseInt(installedNetworkId);
          } catch (_error) {
            // If it can't be parsed into an int like * then don't worry about it
          }
          if (
            installedNetworkId ===
              config.networks[configuredNetwork].network_id ||
            parsedNetworkId === config.networks[configuredNetwork].network_id
          ) {
            found = true;
            break;
          }
        }
        // If we didn't find a suitable configuration, delete this network.
        if (found === false) delete body.networks[installedNetworkId];
      }
      // Our work is done here. Save the file.
      fs.writeFileSync(filePath, JSON.stringify(body, null, 2), "utf8");
      results.push(body);
    });

    // TODO: Display what's removed?
    return results;
  },

  // Try to connect to every named network except for "test" and "development"
  asURIs: async function(options, networks) {
    const result = {
      uris: {},
      failed: []
    };

    for (const networkName of networks) {
      const provider = Provider.create(options.networks[networkName]);
      try {
        const uri = await BlockchainUtils.asURI(provider);
        result.uris[networkName] = uri;
      } catch (error) {
        result.failed.push(networkName);
      }
    }

    return result;
  },

  matchesNetwork: async function(network_id, network_options) {
    const provider = Provider.create(network_options);

    const first = network_id + "";
    const second = network_options.network_id + "";

    if (first === second) return true;

    const isFirstANumber = isNaN(parseInt(network_id)) === false;
    const isSecondANumber =
      isNaN(parseInt(network_options.network_id)) === false;

    // If both network ids are numbers, then they don't match, and we should quit.
    if (isFirstANumber && isSecondANumber) return false;

    const interfaceAdapter = createInterfaceAdapter({
      provider,
      networkType: network_options.type
    });

    const currentNetworkID = await interfaceAdapter.getNetworkId();
    if (first === currentNetworkID) return true;
    if (isFirstANumber === false)
      await BlockchainUtils.matches(first, provider);
    else {
      // Nothing else to compare.
      return false;
    }
  }
};

module.exports = Networks;


/***/ }),

/***/ 883513:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const expect = __webpack_require__(414096);
const TruffleError = __webpack_require__(673321);
const Networks = __webpack_require__(478979);
const EthPM = __webpack_require__(954733);
const EthPMRegistry = __webpack_require__(838182);
const Web3 = __webpack_require__(503283);
const { createInterfaceAdapter } = __webpack_require__(936339);
const path = __webpack_require__(371017);
const fs = __webpack_require__(657147);
const OS = __webpack_require__(822037);

const Package = {
  install: async function(options, callback) {
    const callbackPassed = typeof callback === "function";
    expect.options(options, ["working_directory", "ethpm"]);

    expect.options(options.ethpm, ["registry", "ipfs_host"]);

    expect.one(options.ethpm, ["provider", "install_provider_uri"]);

    // ipfs_port and ipfs_protocol are optinal.

    const provider =
      options.ethpm.provider ||
      new Web3.providers.HttpProvider(options.ethpm.install_provider_uri, {
        keepAlive: false
      });
    let host = options.ethpm.ipfs_host;

    if (host instanceof EthPM.hosts.IPFS === false) {
      host = new EthPM.hosts.IPFSWithLocalReader(
        options.ethpm.ipfs_host,
        options.ethpm.ipfs_port,
        options.ethpm.ipfs_protocol
      );
    }

    // When installing, we use infura to make a bunch of eth_call's.
    // We don't make any transactions. To satisfy APIs we'll put a from address,
    // but it doesn't really matter in this case.
    const fakeAddress = "0x1234567890123456789012345678901234567890";

    let registry = options.ethpm.registry;

    if (typeof registry === "string") {
      try {
        registry = await EthPMRegistry.use(
          options.ethpm.registry,
          fakeAddress,
          provider
        );
      } catch (error) {
        if (callbackPassed) {
          callback(error);
          return;
        }
        throw error;
      }
    }

    const pkg = new EthPM(options.working_directory, host, registry);

    if (options.packages) {
      const promises = options.packages.map(package_name => {
        const pieces = package_name.split("@");
        package_name = pieces[0];

        let version = "*";

        if (pieces.length > 1) version = pieces[1];

        return pkg.installDependency(package_name, version);
      });

      await Promise.all(promises);
      if (options.packages.length > 0) {
        console.log("");
        console.log("Successfully installed the following package(s)...");
        console.log("==================================================");
        options.packages.forEach(singlePackage => {
          console.log(`> ${singlePackage}`);
        });
        console.log("");
      }
      if (callbackPassed) {
        callback();
      }
      return;
    } else {
      let manifest;
      try {
        fs.accessSync(
          path.join(options.working_directory, "ethpm.json"),
          fs.constants.R_OK
        );
      } catch (_error) {
        // If the ethpm.json file doesn't exist, use the config as the manifest.
        manifest = options;
      }
      try {
        await pkg.install(manifest);
        if (callbackPassed) {
          callback();
        }
      } catch (error) {
        if (callbackPassed) {
          callback(error);
          return;
        }
        throw error;
      }
    }
  },

  publish: async function(options, callback) {
    const callbackPassed = typeof callback === "function";
    var self = this;

    expect.options(options, [
      "ethpm",
      "working_directory",
      "contracts_directory",
      "networks"
    ]);

    expect.options(options.ethpm, ["registry", "ipfs_host"]);

    // ipfs_port and ipfs_protocol are optinal.

    // When publishing, you need a ropsten network configured.
    var ropsten = options.networks.ropsten;

    if (!ropsten) {
      const message =
        "You need to have a `ropsten` network configured in " +
        "order to publish to the Ethereum Package Registry. See the " +
        "following link for an example configuration:" +
        OS.EOL +
        OS.EOL +
        "    http://trufflesuite.com/tutorials/using-infura-custom-provider" +
        OS.EOL;
      if (callbackPassed) {
        callback(new TruffleError(message));
        return;
      }
      throw new TruffleError(message);
    }

    options.network = "ropsten";

    var provider = options.provider;
    const interfaceAdapter = createInterfaceAdapter({
      provider: options.provider,
      networkType: "ethereum"
    });
    var host = options.ethpm.ipfs_host;

    if (!(host instanceof EthPM.hosts.IPFS)) {
      host = new EthPM.hosts.IPFS(
        options.ethpm.ipfs_host,
        options.ethpm.ipfs_port,
        options.ethpm.ipfs_protocol
      );
    }

    options.logger.log("Finding publishable artifacts...");

    try {
      const artifacts = await self.publishable_artifacts(options);

      const accs = await interfaceAdapter.getAccounts();
      var registry = await EthPMRegistry.use(
        options.ethpm.registry,
        accs[0],
        provider
      );
      var pkg = new EthPM(options.working_directory, host, registry);
      let manifest;
      try {
        fs.accessSync(
          path.join(options.working_directory, "ethpm.json"),
          fs.constants.R_OK
        );
      } catch (error) {
        // If the ethpm.json file doesn't exist, use the config as the manifest.
        manifest = options;
      }

      options.logger.log("Uploading sources and publishing to registry...");

      // TODO: Gather contract_types and deployments
      const lockfile = await pkg.publish(
        artifacts.contract_types,
        artifacts.deployments,
        manifest
      );
      // If we get here, publishing was a success.
      options.logger.log("+ " + lockfile.package_name + "@" + lockfile.version);
      if (callbackPassed) {
        callback();
      }
      return;
    } catch (error) {
      if (callbackPassed) {
        return callback(error);
      }
      throw error;
    }
  },

  digest: function(options, callback) {
    callback(new Error("Not yet implemented"));
  },

  // Return a list of publishable artifacts
  publishable_artifacts: async function(options, callback) {
    const callbackPassed = typeof callback === "function";
    // Filter out "test" and "development" networks.
    const ifReservedNetworks = new Set(["test", "development"]);
    var deployed_networks = Object.keys(options.networks).filter(
      name => !ifReservedNetworks.has(name)
    );

    // Now get the URIs of each network that's been deployed to.
    let result;
    try {
      result = await Networks.asURIs(options, deployed_networks);
    } catch (error) {
      if (callbackPassed) {
        return callback(err);
      }
      throw err;
    }

    var uris = result.uris;

    if (result.failed.length > 0) {
      const message =
        "Could not connect to the following networks: " +
        result.failed.join(", ") +
        ". These networks have deployed " +
        "artifacts that can't be published as a package without an active " +
        "and accessible connection. Please ensure clients for each " +
        "network are up and running prior to publishing, or use the -n " +
        "option to specify specific networks you'd like published.";
      if (callbackPassed) {
        return callback(new Error(message));
      }
      throw new Error(message);
    }

    var files = fs.readdirSync(options.contracts_build_directory);
    files = files.filter(file => file.endsWith(".json"));

    if (!files.length) {
      const message =
        "Could not locate any publishable artifacts in " +
        options.contracts_build_directory +
        ". " +
        "Run `truffle compile` before publishing.";
      if (callbackPassed) {
        return callback(new Error(message));
      }
      throw new Error(message);
    }

    const promises = files.map(file => {
      return new Promise((resolve, reject) => {
        fs.readFile(
          path.join(options.contracts_build_directory, file),
          "utf8",
          (error, data) => {
            if (error) {
              reject(error);
            }
            resolve(JSON.parse(data));
          }
        );
      });
    });

    const contracts = await Promise.all(promises);

    var contract_types = {};
    var deployments = {};

    // contract_types first.
    contracts.forEach(data => {
      contract_types[data.contractName] = {
        contract_name: data.contractName,
        bytecode: data.bytecode,
        abi: data.abi
      };
    });

    //var network_cache = {};
    const matchingPromises = [];

    contracts.forEach(data => {
      Object.keys(data.networks).forEach(network_id => {
        matchingPromises.push(
          new Promise(async (accept, reject) => {
            try {
              // Go through each deployed network and see if this network matches.
              for (const deployedNetwork of deployed_networks) {
                const matches = await Networks.matchesNetwork(
                  network_id,
                  options.networks[deployedNetwork]
                );
                if (matches) {
                  var uri = uris[deployed_network];

                  if (!deployments[uri]) {
                    deployments[uri] = {};
                  }

                  deployments[uri][data.contractName] = {
                    contract_type: data.contractName, // TODO: Handle conflict resolution
                    address: data.networks[network_id].address
                  };

                  accept();
                }
              }
            } catch (error) {
              reject(error);
            }
          })
        );
      });
    });

    try {
      await Promise.all(matchingPromises);
      const toReturn = {
        contract_types: contract_types,
        deployments: deployments
      };
      if (callbackPassed) {
        callback(null, toReturn);
        return;
      }
      return toReturn;
    } catch (error) {
      if (callbackPassed) {
        return callback(error);
      }
      throw error;
    }
  }
};

module.exports = Package;


/***/ }),

/***/ 902860:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @module googleAnalytics;
 * @requires module:@truffle/config
 * @requires module:universal-analytics
 * @requires module:uuid
 * @requires module:inquirer
 * @requires module:../version
 */

const Config = __webpack_require__(120553);
const userConfig = Config.getUserConfig();
const ua = __webpack_require__(340387);
const uuid = __webpack_require__(171171);

const inquirer = __webpack_require__(496062);

const version = (__webpack_require__(64146).info)();

//set truffleAnalyticsId depending on whether version is bundled
const truffleAnalyticsId = version.bundle ? "UA-83874933-6" : "UA-83874933-7";

const analyticsInquiry = [
  {
    type: "list",
    name: "analyticsInquiry",
    message:
      "Would you like to enable analytics for your Truffle projects? Doing so will allow us to make sure Truffle is working as expected and help us address any bugs more efficiently.",
    choices: ["Yes, enable analytics", "No, do not enable analytics"]
  }
];
const analyticsDisable = [
  {
    type: "confirm",
    name: "analyticsDisable",
    message: "Analytics are currently enabled. Would you like to disable them?",
    default: false
  }
];
const analyticsEnable = [
  {
    type: "confirm",
    name: "analyticsEnable",
    message: "Analytics are currently disabled. Would you like to enable them?",
    default: false
  }
];

const googleAnalytics = {
  /**
   * set user-level unique id
   */
  setUserId: function() {
    if (!userConfig.get("uniqueId")) {
      let userId = uuid();
      userConfig.set({ uniqueId: userId });
    }
  },
  /**
   * get user-level options for analytics
   * @param {Object} userConfig
   * @returns {bool}
   */
  getAnalytics: function() {
    return userConfig.get("enableAnalytics");
  },
  /**
   * set user-level options for analytics
   * @param {bool} analyticsBool
   * @param {Object} userConfig
   */
  setAnalytics: function(analyticsBool) {
    if (analyticsBool === true) {
      this.setUserId();
      console.log('Analytics enabled');
      userConfig.set({
        enableAnalytics: true,
        analyticsSet: true,
        analyticsMessageDateTime: Date.now()
      });
    } else if (analyticsBool === false) {
      console.log('Analytics disabled');
      userConfig.set({
        enableAnalytics: false,
        analyticsSet: true,
        analyticsMessageDateTime: Date.now()
      });
    } else {
      const message =
        `Error setting config option.` +
        `\n> You must set the 'analytics' option to either 'true' ` +
        `or 'false'. \n> The value you provided was ${analyticsBool}.`;
      throw new Error(message);
    }
    return true;
  },
  /**
   * prompt user to determine values for user-level analytics config options
   * @param {Object} userConfig
   */
  setUserConfigViaPrompt: async function() {
    if (!userConfig.get("analyticsSet") && process.stdin.isTTY === true) {
      let answer = await inquirer.prompt(analyticsInquiry);
      if (answer.analyticsInquiry === analyticsInquiry[0].choices[0]) {
        this.setAnalytics(true);
      } else {
        this.setAnalytics(false);
      }
    } else if (
      userConfig.get("analyticsSet") &&
      userConfig.get("enableAnalytics") &&
      process.stdin.isTTY === true
    ) {
      let answer = await inquirer.prompt(analyticsDisable);
      if (answer.analyticsDisable) {
        this.setAnalytics(false);
      } else {
        this.setAnalytics(true);
      }
    } else if (
      userConfig.get("analyticsSet") &&
      !userConfig.get("enableAnalytics") &&
      process.stdin.isTTY === true
    ) {
      let answer = await inquirer.prompt(analyticsEnable);
      if (answer.analyticsEnable) {
        this.setAnalytics(true);
      } else {
        this.setAnalytics(false);
      }
    }
    return true;
  },
  /**
   * check user-level config to see if user has enabled analytics
   * @returns {bool}
   */
  checkIfAnalyticsEnabled: function() {
    if (userConfig.get("enableAnalytics")) {
      return true;
    } else {
      return false;
    }
  },

  /**
   * set data that will be the same in future calls
   * @returns {Object} visitor
   */
  setPersistentAnalyticsData: function() {
    if (this.checkIfAnalyticsEnabled() === true) {
      let userId = userConfig.get("uniqueId");
      let visitor = ua(truffleAnalyticsId, { cid: userId });
      return visitor;
    }
  },

  /**
   * send event to Google Analytics
   * @param {Object}
   */
  // eslint-disable-next-line no-unused-vars
  sendAnalyticsEvent: function(eventObject, callback) {
    let visitor = this.setPersistentAnalyticsData();
    let sendObject = {};
    if (eventObject["command"]) {
      sendObject["ec"] = eventObject["command"];
      sendObject["ea"] = JSON.stringify(eventObject["args"]);
      sendObject["el"] = eventObject["version"];
      sendObject["dp"] = "/" + eventObject["command"];
    } else {
      sendObject["ec"] = "Error";
      sendObject["ea"] = "nonzero exit code";
      sendObject["el"] =
        eventObject["version"] + " " + eventObject["exception"];
      sendObject["dp"] = "/error";
    }

    if (visitor) {
      // eslint-disable-next-line no-unused-vars
      visitor.event(sendObject, function(err) {});
    }

    return true;
  }
};

module.exports = googleAnalytics;


/***/ }),

/***/ 287352:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 287352;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 557817:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 557817;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 784844:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

var Url = __webpack_require__(257310);
var spawn = (__webpack_require__(532081).spawn);
var fs = __webpack_require__(657147);

exports.XMLHttpRequest = function() {
  "use strict";

  /**
   * Private variables
   */
  var self = this;
  var http = __webpack_require__(113685);
  var https = __webpack_require__(795687);

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*",
  };

  var headers = {};
  var headersCase = {};

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;
  
  // Whether cross-site Access-Control requests should be made using
  // credentials such as cookies or authorization headers
  this.withCredentials = false;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw new Error("SecurityError: Request method not allowed");
    }

    settings = {
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request or appends the value if one is already set.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn("Refused to set unsafe header \"" + header + "\"");
      return;
    }
    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send flag is true");
    }
    header = headersCase[header.toLowerCase()] || header;
    headersCase[header.toLowerCase()] = header;
    headers[header] = headers[header] ? headers[header] + ', ' + value : value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response
      && response.headers
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return "";
    }
    var result = "";

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") {
        result += i + ": " + response.headers[i] + "\r\n";
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    if (typeof name === "string" && headersCase[name.toLowerCase()]) {
      return headers[headersCase[name.toLowerCase()]];
    }

    return "";
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
    }

    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send has already been called");
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case "https:":
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case "http:":
        host = url.hostname;
        break;

      case "file:":
        local = true;
        break;

      case undefined:
      case null:
      case "":
        host = "localhost";
        break;

      default:
        throw new Error("Protocol not supported.");
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== "GET") {
        throw new Error("XMLHttpRequest: Only GET method is supported");
      }

      if (settings.async) {
        fs.readFile(url.pathname, "utf8", function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, "utf8");
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : "");

    // Set the defaults if they haven't been set
    for (var name in defaultHeaders) {
      if (!headersCase[name.toLowerCase()]) {
        headers[name] = defaultHeaders[name];
      }
    }

    // Set the Host header or the server may reject the request
    headers.Host = host;
    if (!((ssl && port === 443) || port === 80)) {
      headers.Host += ":" + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password === "undefined") {
        settings.password = "";
      }
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers.Authorization = "Basic " + authBuf.toString("base64");
    }

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") {
      data = null;
    } else if (data) {
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      }
    } else if (settings.method === "POST") {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false,
      withCredentials: self.withCredentials
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      var responseHandler = function responseHandler(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? "GET" : settings.method,
            headers: headers,
            withCredentials: self.withCredentials
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on("error", errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding("utf8");

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on("data", function(chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on("end", function() {
          if (sendFlag) {
            // Discard the end event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on("error", function(error) {
          self.handleError(error);
        });
      };

      // Error handler for the request
      var errorHandler = function errorHandler(error) {
        self.handleError(error);
      };

      // Create the request
      request = doRequest(options, responseHandler).on("error", errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent("loadstart");
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) {"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) {"
        + "  responseText += chunk;"
        + "});"
        + "response.on('end', function() {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "response.on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "}).on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + (data ? "req.write('" + JSON.stringify(data).slice(1,-1).replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);

      if (resp.err) {
        self.handleError(resp.err);
      } else {
        response = resp.data;
        self.status = resp.data.statusCode;
        self.responseText = resp.data.text;
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 0;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
    this.dispatchEvent('error');
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.status = 0;
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
    this.dispatchEvent('abort');
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self["on" + event] === "function") {
      self["on" + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (state == self.LOADING || self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent("readystatechange");
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      }
    }
  };
};


/***/ }),

/***/ 221579:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeSourcePath = void 0;
const utils_1 = __importDefault(__webpack_require__(326086));
const tmp_1 = __importDefault(__webpack_require__(336276));
const path_1 = __importDefault(__webpack_require__(371017));
const config_1 = __importDefault(__webpack_require__(120553));
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const inquirer_1 = __importDefault(__webpack_require__(496062));
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("unbox");
const defaultPath = "git@github.com:trufflesuite/truffle-init-default";
/*
 * accepts a number of different url and org/repo formats and returns the
 * format required by https://www.npmjs.com/package/download-git-repo for remote URLs
 * or absolute path to local folder if the source is local folder
 *
 * supported input formats are as follows:
 *   - org/repo[#branch]
 *   - https://github.com(/|:)<org>/<repo>[.git][#branch]
 *   - git@github.com:<org>/<repo>[#branch]
 *   - path to local folder (absolute, relative or ~/home)
 */
const normalizeSourcePath = (url = defaultPath) => {
    // Process filepath resolution
    //
    if (url.startsWith(".") || url.startsWith("/") || url.startsWith("~")) {
        debug({ in: url, out: path_1.default.normalize(url) });
        return path_1.default.resolve(path_1.default.normalize(url));
    }
    // preprocess to reduce regex complexity
    // `https` is not case sensitiv, unlike `git`
    url = url.replace(/^https/i, "https");
    // branch should not end with slash
    const invalidBranch = /\/$/;
    // process https? or git prefixed input
    //
    if (/^(https?|git)/i.test(url)) {
        // This regular expression uses named capture groups to parse input. The
        // format is (?<the-name>the-regex)
        //
        // \w, the word meta character is a member of [A-Za-z0-9_]. all letters,
        // digits and the underscore. Note \w has to be \\w to escape the backslash
        // in a string literal.
        //
        const protocolRex = new RegExp([
            // match either `htps://` or `git@`
            "(?<protocol>(https://|git@))",
            // service is 1 or many (word, dot or dash)
            "(?<service>[\\w.-]+)",
            // match either `/` or `:`
            "(/|:)",
            // org is 1 or many (word, dot or dash)
            "(?<org>[\\w.-]+)",
            "/",
            // repo is 1 or many (word, dot or dash)
            "(?<repo>[\\w.-]+)",
            // branch is 1 or many (word, dot or dash) and can be optional
            "(?<branch>#[\\w./-]+)?",
            // the input string must be consumed fully at this point to match
            "$",
        ].join(""));
        const match = url.match(protocolRex);
        if (match) {
            const { groups } = match;
            const branch = groups["branch"] || "";
            if (invalidBranch.test(branch)) {
                debug({
                    in: url,
                    error: "InvalidFormat (protocol)",
                    hint: "branch is malformed",
                });
                throw new Error("Box specified with invalid format (git/https)");
            }
            const repo = groups["repo"].replace(/\.git$/i, "");
            const result = `https://${groups["service"]}:${groups["org"]}/${repo}${branch}`;
            debug({ in: url, out: result });
            return result;
        }
        debug({
            in: url,
            error: "InvalidFormat (protocol)",
            hint: "did not match protocol",
        });
        throw new Error("Box specified with invalid format (git/https)");
    }
    // default case: process [org/] + repo + [ #branch/name/with/slashes ]
    //
    const orgRepoBranchRex = new RegExp([
        // start match at beginning
        "^",
        // org is 1 or many (word, dot or dash) followed by a slash. org can be
        // optional
        "(?<org>[\\w.-]+/)?",
        // repo is 1 or many (word, dot or dash)
        "(?<repo>[\\w.-]+)",
        // optional branch (undefined if unmatched)
        "(?<branch>#[\\w./-]+)?",
        "$",
    ].join(""));
    const match = url.match(orgRepoBranchRex);
    if (match) {
        const { groups } = match;
        // `truffle-box` is the default org
        const org = groups["org"] || "truffle-box/";
        const branch = groups["branch"] || "";
        if (invalidBranch.test(branch)) {
            debug({
                in: url,
                error: "InvalidFormat (orgRepoBranch)",
                hint: "branch is malformed",
            });
            throw new Error("Box specified with invalid format");
        }
        let repo = groups["repo"];
        // Official Truffle boxes should have a `-box` suffix
        if (org.toLowerCase().startsWith("truffle-box")) {
            repo = repo.endsWith("-box") ? repo : `${repo}-box`;
        }
        const result = `https://github.com:${org}${repo}${branch}`;
        debug({ in: url, out: result });
        return result;
    }
    // No match, it's an error!
    debug({ in: url, error: "InvalidFormat", hint: "matched nothing" });
    throw new Error("Box specified in invalid format");
};
exports.normalizeSourcePath = normalizeSourcePath;
const parseSandboxOptions = (options) => {
    if (typeof options === "string") {
        // back compatibility for when `options` used to be `name`
        return {
            name: options,
            unsafeCleanup: false,
            setGracefulCleanup: false,
            logger: console,
            force: false,
        };
    }
    else if (typeof options === "object") {
        return {
            name: options.name || "default",
            unsafeCleanup: options.unsafeCleanup || false,
            setGracefulCleanup: options.setGracefulCleanup || false,
            logger: options.logger || console,
            force: options.force || false,
        };
    }
};
const Box = {
    unbox: (url, destination, options = {}, config) => __awaiter(void 0, void 0, void 0, function* () {
        const { events } = config;
        let tempDirCleanup;
        const logger = options.logger || { log: () => { } };
        const unpackBoxOptions = {
            logger: options.logger,
            force: options.force,
        };
        try {
            const normalizedSourcePath = exports.normalizeSourcePath(url);
            yield Box.checkDir(options, destination);
            const tempDir = utils_1.default.setUpTempDirectory(events);
            const tempDirPath = tempDir.path;
            tempDirCleanup = tempDir.cleanupCallback;
            yield utils_1.default.downloadBox(normalizedSourcePath, tempDirPath, events);
            const boxConfig = yield utils_1.default.readBoxConfig(tempDirPath);
            yield utils_1.default.unpackBox(tempDirPath, destination, boxConfig, unpackBoxOptions);
            events.emit("unbox:cleaningTempFiles:start");
            tempDirCleanup();
            events.emit("unbox:cleaningTempFiles:succeed");
            utils_1.default.setUpBox(boxConfig, destination, events);
            return boxConfig;
        }
        catch (error) {
            if (tempDirCleanup)
                tempDirCleanup();
            events.emit("unbox:fail");
            throw error;
        }
    }),
    checkDir: (options = {}, destination) => __awaiter(void 0, void 0, void 0, function* () {
        let logger = options.logger || console;
        if (!options.force) {
            const unboxDir = fs_extra_1.default.readdirSync(destination);
            if (unboxDir.length) {
                logger.log(`This directory is non-empty...`);
                const prompt = [
                    {
                        type: "confirm",
                        name: "proceed",
                        message: `Proceed anyway?`,
                        default: true,
                    },
                ];
                const answer = yield inquirer_1.default.prompt(prompt);
                if (!answer.proceed) {
                    logger.log("Unbox cancelled");
                    process.exit();
                }
            }
        }
    }),
    // options.unsafeCleanup
    //   Recursively removes the created temporary directory, even when it's not empty. default is false
    // options.setGracefulCleanup
    //   Cleanup temporary files even when an uncaught exception occurs
    sandbox: (options) => __awaiter(void 0, void 0, void 0, function* () {
        const { name, unsafeCleanup, setGracefulCleanup, logger, force, } = parseSandboxOptions(options);
        const boxPath = name.replace(/^default(?=#|$)/, defaultPath);
        //ordinarily, this line will have no effect.  however, if the name is "default",
        //possibly with a branch specification, this replaces it appropriately
        //(this is necessary in order to keep using trufflesuite/truffle-init-default
        //instead of truffle-box/etc)
        if (setGracefulCleanup)
            tmp_1.default.setGracefulCleanup();
        let config = new config_1.default();
        const tmpDir = tmp_1.default.dirSync({ unsafeCleanup });
        const unboxOptions = { logger, force };
        yield Box.unbox(boxPath, tmpDir.name, unboxOptions, config);
        return config_1.default.load(path_1.default.join(tmpDir.name, "truffle-config.js"), {});
    }),
};
exports["default"] = Box;
//# sourceMappingURL=box.js.map

/***/ }),

/***/ 77220:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(655674));
function setDefaults(config = {}) {
    const hooks = config.hooks || {};
    return {
        ignore: config.ignore || [],
        commands: config.commands || {
            compile: "truffle compile",
            migrate: "truffle migrate",
            test: "truffle test"
        },
        hooks: {
            "post-unpack": hooks["post-unpack"] || ""
        }
    };
}
function read(path) {
    return fs_extra_1.default
        .readFile(path)
        .catch(() => "{}")
        .then(JSON.parse)
        .then(setDefaults);
}
module.exports = {
    read,
    setDefaults
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ 326086:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const unbox_1 = __importDefault(__webpack_require__(91104));
const fs_1 = __importDefault(__webpack_require__(657147));
const config_1 = __importDefault(__webpack_require__(77220));
const tmp_1 = __importDefault(__webpack_require__(336276));
const path_1 = __importDefault(__webpack_require__(371017));
module.exports = {
    downloadBox: (source, destination, events) => __awaiter(void 0, void 0, void 0, function* () {
        events.emit("unbox:downloadingBox:start");
        yield unbox_1.default.verifySourcePath(source);
        yield unbox_1.default.fetchRepository(source, destination);
        events.emit("unbox:downloadingBox:succeed");
    }),
    readBoxConfig: (destination) => __awaiter(void 0, void 0, void 0, function* () {
        const possibleConfigs = [
            path_1.default.join(destination, "truffle-box.json"),
            path_1.default.join(destination, "truffle-init.json")
        ];
        const configPath = possibleConfigs.reduce((path, alt) => path || (fs_1.default.existsSync(alt) && alt), undefined);
        return yield config_1.default.read(configPath);
    }),
    setUpTempDirectory: (events) => {
        events.emit("unbox:preparingToDownload:start");
        const options = {
            unsafeCleanup: true
        };
        const tmpDir = tmp_1.default.dirSync(options);
        events.emit("unbox:preparingToDownload:succeed");
        return {
            path: path_1.default.join(tmpDir.name, "box"),
            cleanupCallback: tmpDir.removeCallback
        };
    },
    unpackBox: (tempDir, destination, boxConfig, unpackBoxOptions) => __awaiter(void 0, void 0, void 0, function* () {
        unbox_1.default.prepareToCopyFiles(tempDir, boxConfig);
        yield unbox_1.default.copyTempIntoDestination(tempDir, destination, unpackBoxOptions);
    }),
    setUpBox: (boxConfig, destination, events) => {
        events.emit("unbox:settingUpBox:start");
        unbox_1.default.installBoxDependencies(boxConfig, destination);
        events.emit("unbox:settingUpBox:succeed");
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 91104:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const path_1 = __importDefault(__webpack_require__(371017));
const download_git_repo_1 = __importDefault(__webpack_require__(120448));
const axios_1 = __importDefault(__webpack_require__(409669));
const vcsurl_1 = __importDefault(__webpack_require__(309627));
const url_1 = __webpack_require__(257310);
const child_process_1 = __webpack_require__(532081);
const inquirer_1 = __importDefault(__webpack_require__(496062));
const util_1 = __webpack_require__(473837);
const ignore_1 = __importDefault(__webpack_require__(754877));
function verifyLocalPath(localPath) {
    const configPath = path_1.default.join(localPath, "truffle-box.json");
    fs_extra_1.default.access(configPath).catch(_e => {
        throw new Error(`Truffle Box at path ${localPath} doesn't exist.`);
    });
}
function verifyVCSURL(url) {
    return __awaiter(this, void 0, void 0, function* () {
        // Next let's see if the expected repository exists. If it doesn't, ghdownload
        // will fail spectacularly in a way we can't catch, so we have to do it ourselves.
        const configURL = url_1.parse(`${vcsurl_1.default(url)
            .replace("github.com", "raw.githubusercontent.com")
            .replace(/#.*/, "")}/master/truffle-box.json`);
        const repoUrl = `https://${configURL.host}${configURL.path}`;
        try {
            yield axios_1.default.head(repoUrl, { maxRedirects: 50 });
        }
        catch (error) {
            if (error.response && error.response.status === 404) {
                throw new Error(`Truffle Box at URL ${url} doesn't exist. If you believe this is an error, please contact Truffle support.`);
            }
            else {
                const prefix = `Error connecting to ${repoUrl}. Please check your internet connection and try again.`;
                error.message = `${prefix}\n\n${error.message || ''}`;
                throw error;
            }
        }
    });
}
function verifySourcePath(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            return verifyLocalPath(sourcePath);
        }
        return verifyVCSURL(sourcePath);
    });
}
function gitIgnoreFilter(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const ignoreFilter = ignore_1.default();
        try {
            const gitIgnore = yield fs_extra_1.default.readFile(path_1.default.join(sourcePath, ".gitignore"), "utf8");
            ignoreFilter.add(gitIgnore.split(/\r?\n/).map(p => p.replace(/\/$/, "")));
        }
        catch (err) { }
        return ignoreFilter;
    });
}
function fetchRepository(sourcePath, dir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            const filter = yield gitIgnoreFilter(sourcePath);
            return fs_extra_1.default.copy(sourcePath, dir, {
                filter: file => sourcePath === file || !filter.ignores(path_1.default.relative(sourcePath, file))
            });
        }
        return util_1.promisify(download_git_repo_1.default)(sourcePath, dir);
    });
}
function prepareToCopyFiles(tempDir, { ignore }) {
    const needingRemoval = ignore;
    // remove box config file
    needingRemoval.push("truffle-box.json");
    needingRemoval.push("truffle-init.json");
    needingRemoval
        .map((fileName) => path_1.default.join(tempDir, fileName))
        .forEach((filePath) => fs_extra_1.default.removeSync(filePath));
}
function promptOverwrites(contentCollisions, logger = console) {
    return __awaiter(this, void 0, void 0, function* () {
        const overwriteContents = [];
        for (const file of contentCollisions) {
            logger.log(`${file} already exists in this directory...`);
            const overwriting = [
                {
                    type: "confirm",
                    name: "overwrite",
                    message: `Overwrite ${file}?`,
                    default: false
                }
            ];
            const { overwrite } = yield inquirer_1.default.prompt(overwriting);
            if (overwrite) {
                fs_extra_1.default.removeSync(file);
                overwriteContents.push(file);
            }
        }
        return overwriteContents;
    });
}
function copyTempIntoDestination(tmpDir, destination, options) {
    return __awaiter(this, void 0, void 0, function* () {
        fs_extra_1.default.ensureDirSync(destination);
        const { force, logger } = options;
        const boxContents = fs_extra_1.default.readdirSync(tmpDir);
        const destinationContents = fs_extra_1.default.readdirSync(destination);
        const newContents = boxContents.filter(filename => !destinationContents.includes(filename));
        const contentCollisions = boxContents.filter(filename => destinationContents.includes(filename));
        let shouldCopy;
        if (force) {
            shouldCopy = boxContents;
        }
        else {
            const overwriteContents = yield promptOverwrites(contentCollisions, logger);
            shouldCopy = [...newContents, ...overwriteContents];
        }
        for (const file of shouldCopy) {
            fs_extra_1.default.copySync(`${tmpDir}/${file}`, `${destination}/${file}`);
        }
    });
}
function installBoxDependencies({ hooks }, destination) {
    const postUnpack = hooks["post-unpack"];
    if (postUnpack.length === 0)
        return;
    child_process_1.execSync(postUnpack, { cwd: destination });
}
module.exports = {
    copyTempIntoDestination,
    fetchRepository,
    installBoxDependencies,
    prepareToCopyFiles,
    verifySourcePath,
    verifyVCSURL
};
//# sourceMappingURL=unbox.js.map

/***/ }),

/***/ 876775:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 876775;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 396524:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardMessageBus = void 0;
const events_1 = __webpack_require__(582361);
const dashboard_message_bus_common_1 = __webpack_require__(175756);
const utils_1 = __webpack_require__(944794);
const util_1 = __webpack_require__(473837);
class DashboardMessageBus extends events_1.EventEmitter {
    constructor(publishPort, subscribePort, host = "localhost") {
        super();
        this.publishPort = publishPort;
        this.subscribePort = subscribePort;
        this.host = host;
        this.publishers = [];
        this.subscribers = [];
        this.unfulfilledRequests = new Map([]);
        this.resetReadyState();
    }
    /**
     * Start the DashboardMessageBus
     * @dev This starts separate websocket servers for subscribers/publishers
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.subscribeServer = yield utils_1.startWebSocketServer({
                host: this.host,
                port: this.subscribePort
            });
            this.subscribeServer.on("connection", (newSubscriber) => {
                newSubscriber.once("close", () => {
                    this.removeSubscriber(newSubscriber);
                });
                // Require the subscriber to send a message *first* before being added
                newSubscriber.once("message", () => this.addSubscriber(newSubscriber));
            });
            this.publishServer = yield utils_1.startWebSocketServer({
                host: this.host,
                port: this.publishPort
            });
            this.publishServer.on("connection", (newPublisher) => {
                newPublisher.once("close", () => {
                    this.removePublisher(newPublisher);
                });
                this.addPublisher(newPublisher);
            });
        });
    }
    /**
     * A promise that resolves when the message bus is ready to process requests
     * (i.e. having any subscribers).
     */
    get ready() {
        return this.readyPromise;
    }
    /**
     * Close both websocket servers
     * @dev Emits a "terminate" event
     */
    terminate() {
        return __awaiter(this, void 0, void 0, function* () {
            yield util_1.promisify(this.publishServer.close.bind(this.publishServer))();
            yield util_1.promisify(this.subscribeServer.close.bind(this.subscribeServer))();
            this.emit("terminate");
        });
    }
    /**
     * Process a message `data` coming from `publisher` by sending it to `subscribers`
     * and return the first received response to the `publisher`
     */
    processRequest(publisher, data, subscribers) {
        return __awaiter(this, void 0, void 0, function* () {
            // convert to string for uniformity since WebSocket.Data can take other forms
            if (typeof data !== "string") {
                data = data.toString();
            }
            yield this.ready;
            this.unfulfilledRequests.set(data, { publisher, data });
            const message = dashboard_message_bus_common_1.base64ToJson(data);
            try {
                this.logToPublishers(`Sending message to ${subscribers.length} subscribers`, "requests");
                this.logToPublishers(message, "requests");
                const response = yield utils_1.broadcastAndAwaitFirst(subscribers, message);
                this.logToPublishers(`Sending response for message ${message.id}`, "responses");
                this.logToPublishers(response, "responses");
                const encodedResponse = dashboard_message_bus_common_1.jsonToBase64(response);
                publisher.send(encodedResponse);
                this.unfulfilledRequests.delete(data);
                this.invalidateMessage(message.id);
            }
            catch (error) {
                this.logToPublishers(`An error occurred while processing message ${message.id}`, "errors");
                this.logToPublishers(error, "errors");
            }
        });
    }
    invalidateMessage(id) {
        const invalidationMessage = dashboard_message_bus_common_1.createMessage("invalidate", id);
        utils_1.broadcastAndDisregard(this.subscribers, invalidationMessage);
    }
    logToPublishers(logMessage, namespace) {
        this.logTo(logMessage, this.publishers, namespace);
    }
    logToSubscribers(logMessage, namespace) {
        this.logTo(logMessage, this.subscribers, namespace);
    }
    logToAll(logMessage, namespace) {
        this.logToPublishers(logMessage, namespace);
        this.logToSubscribers(logMessage, namespace);
    }
    logTo(logMessage, receivers, namespace) {
        const payload = {
            namespace: "dashboard-message-bus",
            message: logMessage
        };
        if (namespace) {
            payload.namespace += `:${namespace}`;
        }
        const message = dashboard_message_bus_common_1.createMessage("log", payload);
        utils_1.broadcastAndDisregard(receivers, message);
    }
    /**
     * Add a publisher so it can be used to send requests to
     * @dev Also sends all backlogged (unfulfilled) requests upon connection
     */
    addSubscriber(newSubscriber) {
        this.unfulfilledRequests.forEach(({ publisher, data }) => this.processRequest(publisher, data, [newSubscriber]));
        this.logToPublishers("Subscriber connected", "connections");
        this.subscribers.push(newSubscriber);
        if (this.subscribers.length == 1) {
            this.resolveReadyPromise();
        }
    }
    /**
     * Remove a subscriber
     * @dev Will cause the server to terminate if this was the last connection
     */
    removeSubscriber(subscriberToRemove) {
        this.logToPublishers("Subscriber disconnected", "connections");
        this.subscribers = this.subscribers.filter(subscriber => subscriber !== subscriberToRemove);
        if (this.subscribers.length === 0) {
            this.resetReadyState();
        }
        this.terminateIfNoConnections();
    }
    /**
     * Add a publisher and set up message listeners to process their requests
     */
    addPublisher(newPublisher) {
        this.logToPublishers("Publisher connected", "connections");
        newPublisher.on("message", (data) => {
            this.processRequest(newPublisher, data, this.subscribers);
        });
        this.publishers.push(newPublisher);
    }
    /**
     * Remove a publisher and their corresponding requests
     * @dev Will cause the server to terminate if this was the last connection
     */
    removePublisher(publisherToRemove) {
        this.logToPublishers("Publisher disconnected", "connections");
        this.publishers = this.publishers.filter(publisher => publisher !== publisherToRemove);
        this.clearRequestsForPublisher(publisherToRemove);
        this.terminateIfNoConnections();
    }
    terminateIfNoConnections() {
        if (this.publishers.length === 0 && this.subscribers.length === 0) {
            this.terminate();
        }
    }
    clearRequestsForPublisher(publisher) {
        this.unfulfilledRequests.forEach(({ publisher: requestPublisher }, key) => {
            if (requestPublisher === publisher) {
                this.unfulfilledRequests.delete(key);
            }
        });
    }
    resetReadyState() {
        this.readyPromise = new Promise((resolve => {
            this.resolveReadyPromise = resolve;
        }).bind(this));
    }
}
exports.DashboardMessageBus = DashboardMessageBus;
//# sourceMappingURL=DashboardMessageBus.js.map

/***/ }),

/***/ 737108:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(396524), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 944794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendAndAwait = exports.broadcastAndAwaitFirst = exports.broadcastAndDisregard = exports.startWebSocketServer = void 0;
const isomorphic_ws_1 = __importDefault(__webpack_require__(347030));
const dashboard_message_bus_common_1 = __webpack_require__(175756);
const promise_any_1 = __importDefault(__webpack_require__(625795));
promise_any_1.default.shim();
/**
 * Starts a websocket server and waits for it to be opened
 * @dev If you need to attach event listeners *before* the server connection opens,
 * do not use this function since it resolves *after* the connection is opened
 */
const startWebSocketServer = (options) => {
    return new Promise(resolve => {
        const server = new isomorphic_ws_1.default.Server(options, () => {
            resolve(server);
        });
    });
};
exports.startWebSocketServer = startWebSocketServer;
/**
 * Broadcast a message to multiple websocket connections and disregard them
 */
const broadcastAndDisregard = (sockets, message) => {
    const encodedMessage = dashboard_message_bus_common_1.jsonToBase64(message);
    sockets.forEach(socket => {
        socket.send(encodedMessage);
    });
};
exports.broadcastAndDisregard = broadcastAndDisregard;
/**
 * Broadcast a message to multuple websocket connections and return the first response
 */
const broadcastAndAwaitFirst = (sockets, message) => __awaiter(void 0, void 0, void 0, function* () {
    const promises = sockets.map(socket => exports.sendAndAwait(socket, message));
    const result = yield Promise.any(promises);
    return result;
});
exports.broadcastAndAwaitFirst = broadcastAndAwaitFirst;
/**
 * Send a message to a websocket connection and await a matching response
 * @dev Responses are matched by looking at received messages that match the ID of the sent message
 */
const sendAndAwait = (socket, message) => {
    return new Promise((resolve, reject) => {
        socket.addEventListener("message", (event) => {
            if (typeof event.data !== "string") {
                event.data = event.data.toString();
            }
            const response = dashboard_message_bus_common_1.base64ToJson(event.data);
            if (response.id !== message.id)
                return;
            resolve(response);
        });
        // TODO: Need to check that the error corresponds to the sent message?
        socket.addEventListener("error", (event) => {
            reject(event.error);
        });
        socket.addEventListener("close", (event) => {
            reject(new Error(`Socket connection closed with code '${event.code}' and reason '${event.reason}'`));
        });
        const encodedMessage = dashboard_message_bus_common_1.jsonToBase64(message);
        socket.send(encodedMessage);
    });
};
exports.sendAndAwait = sendAndAwait;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 866205:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardServer = void 0;
const express_1 = __importDefault(__webpack_require__(999268));
const path_1 = __importDefault(__webpack_require__(371017));
const get_port_1 = __importDefault(__webpack_require__(715959));
const open_1 = __importDefault(__webpack_require__(678318));
const dashboard_message_bus_common_1 = __webpack_require__(175756);
const dashboard_message_bus_1 = __webpack_require__(737108);
const dashboard_message_bus_client_1 = __webpack_require__(319602);
const cors_1 = __importDefault(__webpack_require__(917846));
const debug_1 = __importDefault(__webpack_require__(791258));
class DashboardServer {
    constructor(options) {
        var _a, _b, _c, _d;
        this.host = (_a = options.host) !== null && _a !== void 0 ? _a : "localhost";
        this.port = options.port;
        this.configPublishPort = options.publishPort;
        this.configSubscribePort = options.subscribePort;
        this.rpc = (_b = options.rpc) !== null && _b !== void 0 ? _b : true;
        this.verbose = (_c = options.verbose) !== null && _c !== void 0 ? _c : false;
        this.autoOpen = (_d = options.autoOpen) !== null && _d !== void 0 ? _d : true;
        this.frontendPath = path_1.default.join(__dirname, ".", "dashboard-frontend", "build");
        this.boundTerminateListener = () => this.stop();
    }
    get subscribePort() {
        var _a;
        return (_a = this.messageBus) === null || _a === void 0 ? void 0 : _a.subscribePort;
    }
    get publishPort() {
        var _a;
        return (_a = this.messageBus) === null || _a === void 0 ? void 0 : _a.subscribePort;
    }
    start() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.listening) {
                return;
            }
            this.messageBus = yield this.startMessageBus();
            this.expressApp = express_1.default();
            this.expressApp.use(cors_1.default());
            this.expressApp.use(express_1.default.json());
            this.expressApp.use(express_1.default.static(this.frontendPath));
            this.expressApp.get("/ports", this.getPorts.bind(this));
            if (this.rpc) {
                yield this.connectToMessageBus();
                this.expressApp.post("/rpc", this.postRpc.bind(this));
            }
            yield new Promise(resolve => {
                this.httpServer = this.expressApp.listen(this.port, this.host, () => {
                    if (this.autoOpen) {
                        const host = this.host === "0.0.0.0" ? "localhost" : this.host;
                        open_1.default(`http://${host}:${this.port}`);
                    }
                    resolve();
                });
            });
        });
    }
    stop() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = this.messageBus) === null || _a === void 0 ? void 0 : _a.off("terminate", this.boundTerminateListener);
            yield Promise.all([
                (_b = this.client) === null || _b === void 0 ? void 0 : _b.close(),
                (_c = this.messageBus) === null || _c === void 0 ? void 0 : _c.terminate(),
                new Promise(resolve => {
                    var _a;
                    (_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.close(() => resolve());
                })
            ]);
            delete this.client;
        });
    }
    getPorts(req, res) {
        if (!this.messageBus) {
            throw new Error("Message bus has not been started yet");
        }
        res.json({
            dashboardPort: this.port,
            subscribePort: this.messageBus.subscribePort,
            publishPort: this.messageBus.publishPort
        });
    }
    postRpc(req, res, next) {
        if (!this.client) {
            throw new Error("Not connected to message bus");
        }
        this.client
            .publish({ type: dashboard_message_bus_common_1.dashboardProviderMessageType, payload: req.body })
            .then(lifecycle => lifecycle.response)
            .then(response => res.json(response === null || response === void 0 ? void 0 : response.payload))
            .catch(next);
    }
    startMessageBus() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const subscribePort = (_a = this.configSubscribePort) !== null && _a !== void 0 ? _a : (yield get_port_1.default({ host: this.host }));
            const publishPort = (_b = this.configPublishPort) !== null && _b !== void 0 ? _b : (yield get_port_1.default({ host: this.host }));
            const messageBus = new dashboard_message_bus_1.DashboardMessageBus(publishPort, subscribePort, this.host);
            yield messageBus.start();
            messageBus.on("terminate", this.boundTerminateListener);
            return messageBus;
        });
    }
    connectToMessageBus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.messageBus) {
                throw new Error("Message bus has not been started yet");
            }
            if (this.client) {
                return;
            }
            this.client = new dashboard_message_bus_client_1.DashboardMessageBusClient({
                host: this.host,
                subscribePort: this.messageBus.subscribePort,
                publishPort: this.messageBus.publishPort
            });
            yield this.client.ready();
            // the promise returned by `setupVerboseLogging` never resolves, so don't
            // bother awaiting it.
            this.setupVerboseLogging();
        });
    }
    setupVerboseLogging() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.verbose && this.client) {
                this.client
                    .subscribe({ type: dashboard_message_bus_common_1.logMessageType })
                    .on("message", lifecycle => {
                    if (lifecycle && lifecycle.message.type === "log") {
                        const logMessage = lifecycle.message;
                        const debug = debug_1.default(logMessage.payload.namespace);
                        debug.enabled = true;
                        debug(logMessage.payload.message);
                    }
                });
            }
        });
    }
}
exports.DashboardServer = DashboardServer;
//# sourceMappingURL=DashboardServer.js.map

/***/ }),

/***/ 897722:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(866205), exports);
__exportStar(__webpack_require__(732550), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 732550:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startDashboardInBackground = void 0;
const dashboard_message_bus_common_1 = __webpack_require__(175756);
const child_process_1 = __webpack_require__(532081);
const path_1 = __importDefault(__webpack_require__(371017));
const startDashboardInBackground = (options) => {
    const dashboardPath = path_1.default.join(__dirname, "..", "bin", "start-dashboard");
    const optionsBase64 = dashboard_message_bus_common_1.jsonToBase64(options);
    const child = child_process_1.spawn("node", [dashboardPath, optionsBase64], {
        detached: true,
        stdio: "ignore"
    });
    return child;
};
exports.startDashboardInBackground = startDashboardInBackground;
//# sourceMappingURL=utils.js.map

/***/ })

};
;
//# sourceMappingURL=7941.bundled.js.map